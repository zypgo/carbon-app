# æ™ºèƒ½åˆçº¦æ·±åº¦åˆ†æ

## 1. æ™ºèƒ½åˆçº¦ABIå®Œæ•´åˆ†æ

### 1.1 åˆçº¦æ¥å£æ¦‚è§ˆ

```json
// src/contracts/CarbonCreditSystem.json - å®Œæ•´ABIå®šä¹‰
[
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "string",
        "name": "activity",
        "type": "string"
      }
    ],
    "name": "recordEmission",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getUserEmissions",
    "outputs": [
      {
        "components": [
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "timestamp",
            "type": "uint256"
          },
          {
            "internalType": "string",
            "name": "activity",
            "type": "string"
          }
        ],
        "internalType": "struct CarbonCreditSystem.EmissionRecord[]",
        "name": "",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      }
    ],
    "name": "listCredit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "listingId",
        "type": "uint256"
      }
    ],
    "name": "buyCredit",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getAllListings",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "seller",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "price",
            "type": "uint256"
          },
          {
            "internalType": "bool",
            "name": "active",
            "type": "bool"
          }
        ],
        "internalType": "struct CarbonCreditSystem.CreditListing[]",
        "name": "",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "activity",
        "type": "string"
      }
    ],
    "name": "EmissionRecorded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "buyer",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "seller",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      }
    ],
    "name": "CreditPurchased",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "seller",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      }
    ],
    "name": "CreditListed",
    "type": "event"
  }
]
```

## 2. æ™ºèƒ½åˆçº¦åŠŸèƒ½è¯¦ç»†åˆ†æ

### 2.1 æ’æ”¾è®°å½•åŠŸèƒ½ (recordEmission)

```solidity
// å¯¹åº”çš„Solidityåˆçº¦æ–¹æ³•ï¼ˆæ¨æµ‹å®ç°ï¼‰
struct EmissionRecord {
    uint256 amount;      // æ’æ”¾é‡ï¼ˆä»¥Weiä¸ºå•ä½ï¼‰
    uint256 timestamp;   // åŒºå—æ—¶é—´æˆ³
    string activity;     // æ´»åŠ¨ç±»å‹
}

// ç”¨æˆ·æ’æ”¾è®°å½•æ˜ å°„
mapping(address => EmissionRecord[]) public userEmissions;

/**
 * @dev è®°å½•ç”¨æˆ·çš„ç¢³æ’æ”¾æ•°æ®
 * @param amount æ’æ”¾é‡ï¼ˆä»¥Weiä¸ºå•ä½ï¼Œéœ€è¦å‰ç«¯è½¬æ¢ï¼‰
 * @param activity æ’æ”¾æ´»åŠ¨ç±»å‹ï¼ˆå¦‚"äº¤é€š"ã€"ç”¨ç”µ"ç­‰ï¼‰
 */
function recordEmission(uint256 amount, string memory activity) public {
    // åˆ›å»ºæ’æ”¾è®°å½•
    EmissionRecord memory newRecord = EmissionRecord({
        amount: amount,
        timestamp: block.timestamp,  // ä½¿ç”¨åŒºå—æ—¶é—´æˆ³
        activity: activity
    });
    
    // æ·»åŠ åˆ°ç”¨æˆ·çš„æ’æ”¾è®°å½•æ•°ç»„
    userEmissions[msg.sender].push(newRecord);
    
    // è§¦å‘äº‹ä»¶ï¼Œä¾¿äºå‰ç«¯ç›‘å¬
    emit EmissionRecorded(msg.sender, amount, activity);
}

/**
 * @dev è·å–è°ƒç”¨è€…çš„æ‰€æœ‰æ’æ”¾è®°å½•
 * @return ç”¨æˆ·çš„æ’æ”¾è®°å½•æ•°ç»„
 */
function getUserEmissions() public view returns (EmissionRecord[] memory) {
    return userEmissions[msg.sender];
}
```

#### å‰ç«¯è°ƒç”¨ç¤ºä¾‹
```typescript
// æ­£ç¡®çš„å‰ç«¯è°ƒç”¨æ–¹å¼
const recordEmission = async (amount: number, activity: string) => {
  try {
    // å°†æ•°é‡è½¬æ¢ä¸ºWeiå•ä½ï¼ˆåŒºå—é“¾æ ‡å‡†ï¼‰
    const amountInWei = ethers.parseEther(amount.toString())
    
    // è°ƒç”¨æ™ºèƒ½åˆçº¦æ–¹æ³•
    const tx = await contract.recordEmission(amountInWei, activity)
    
    // ç­‰å¾…äº¤æ˜“è¢«çŸ¿å·¥ç¡®è®¤
    const receipt = await tx.wait()
    
    console.log('æ’æ”¾è®°å½•å·²ä¸Šé“¾:', {
      transactionHash: receipt.hash,
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed.toString()
    })
    
    return receipt
  } catch (error) {
    console.error('è®°å½•æ’æ”¾å¤±è´¥:', error)
    throw error
  }
}

// è·å–ç”¨æˆ·æ’æ”¾è®°å½•
const getUserEmissions = async () => {
  try {
    const emissions = await contract.getUserEmissions()
    
    // æ ¼å¼åŒ–æ•°æ®ä¾›å‰ç«¯ä½¿ç”¨
    return emissions.map(emission => ({
      amount: ethers.formatEther(emission.amount), // ä»Weiè½¬æ¢ä¸ºEther
      timestamp: Number(emission.timestamp) * 1000, // è½¬æ¢ä¸ºæ¯«ç§’
      activity: emission.activity
    }))
  } catch (error) {
    console.error('è·å–æ’æ”¾è®°å½•å¤±è´¥:', error)
    return []
  }
}
```

### 2.2 ç¢³ä¿¡ç”¨äº¤æ˜“åŠŸèƒ½

#### 2.2.1 ä¸Šæ¶ç¢³ä¿¡ç”¨ (listCredit)

```solidity
// ç¢³ä¿¡ç”¨ä¸Šæ¶ç»“æ„
struct CreditListing {
    address seller;      // å–å®¶åœ°å€
    uint256 amount;      // ç¢³ä¿¡ç”¨æ•°é‡
    uint256 price;       // å•ä»·ï¼ˆä»¥Weiä¸ºå•ä½ï¼‰
    bool active;         // æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
}

// æ‰€æœ‰ä¸Šæ¶ä¿¡æ¯æ•°ç»„
CreditListing[] public listings;

/**
 * @dev ä¸Šæ¶ç¢³ä¿¡ç”¨è¿›è¡Œé”€å”®
 * @param amount ç¢³ä¿¡ç”¨æ•°é‡
 * @param price å•ä»·ï¼ˆä»¥Weiä¸ºå•ä½ï¼‰
 */
function listCredit(uint256 amount, uint256 price) public {
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰è¶³å¤Ÿçš„ç¢³ä¿¡ç”¨
    require(carbonCredits[msg.sender] >= amount, "ä½™é¢ä¸è¶³");
    
    // åˆ›å»ºä¸Šæ¶ä¿¡æ¯
    CreditListing memory newListing = CreditListing({
        seller: msg.sender,
        amount: amount,
        price: price,
        active: true
    });
    
    // æ·»åŠ åˆ°ä¸Šæ¶åˆ—è¡¨
    listings.push(newListing);
    
    // å†»ç»“ç”¨æˆ·çš„ç¢³ä¿¡ç”¨ï¼ˆé˜²æ­¢é‡å¤é”€å”®ï¼‰
    carbonCredits[msg.sender] -= amount;
    
    // è§¦å‘ä¸Šæ¶äº‹ä»¶
    emit CreditListed(msg.sender, amount, price);
}
```

#### å‰ç«¯è°ƒç”¨ç¤ºä¾‹
```typescript
const listCredit = async (amount: number, price: number) => {
  try {
    // è½¬æ¢ä¸ºWeiå•ä½
    const amountInWei = ethers.parseEther(amount.toString())
    const priceInWei = ethers.parseEther(price.toString())
    
    // è°ƒç”¨æ™ºèƒ½åˆçº¦
    const tx = await contract.listCredit(amountInWei, priceInWei)
    const receipt = await tx.wait()
    
    console.log('ç¢³ä¿¡ç”¨å·²ä¸Šæ¶:', {
      transactionHash: receipt.hash,
      amount: amount,
      price: price
    })
    
    return receipt
  } catch (error) {
    console.error('ä¸Šæ¶å¤±è´¥:', error)
    throw error
  }
}
```

#### 2.2.2 è´­ä¹°ç¢³ä¿¡ç”¨ (buyCredit)

```solidity
/**
 * @dev è´­ä¹°æŒ‡å®šçš„ç¢³ä¿¡ç”¨
 * @param listingId ä¸Šæ¶ä¿¡æ¯çš„IDï¼ˆæ•°ç»„ç´¢å¼•ï¼‰
 */
function buyCredit(uint256 listingId) public payable {
    // æ£€æŸ¥ä¸Šæ¶ä¿¡æ¯æ˜¯å¦å­˜åœ¨ä¸”æœ‰æ•ˆ
    require(listingId < listings.length, "ä¸Šæ¶ä¿¡æ¯ä¸å­˜åœ¨");
    require(listings[listingId].active, "è¯¥ç¢³ä¿¡ç”¨å·²è¢«è´­ä¹°");
    
    CreditListing storage listing = listings[listingId];
    
    // è®¡ç®—æ€»ä»·
    uint256 totalPrice = listing.amount * listing.price;
    require(msg.value >= totalPrice, "æ”¯ä»˜é‡‘é¢ä¸è¶³");
    
    // è½¬ç§»ç¢³ä¿¡ç”¨ç»™ä¹°å®¶
    carbonCredits[msg.sender] += listing.amount;
    
    // å°†ETHè½¬ç»™å–å®¶
    payable(listing.seller).transfer(totalPrice);
    
    // å¦‚æœæ”¯ä»˜é‡‘é¢è¶…è¿‡æ€»ä»·ï¼Œé€€è¿˜å¤šä½™éƒ¨åˆ†
    if (msg.value > totalPrice) {
        payable(msg.sender).transfer(msg.value - totalPrice);
    }
    
    // æ ‡è®°ä¸ºå·²å”®å‡º
    listing.active = false;
    
    // è§¦å‘è´­ä¹°äº‹ä»¶
    emit CreditPurchased(msg.sender, listing.seller, listing.amount, totalPrice);
}
```

#### å‰ç«¯è°ƒç”¨ç¤ºä¾‹
```typescript
const buyCredit = async (listingId: number, totalPrice: number) => {
  try {
    // è½¬æ¢ä¸ºWeiå•ä½
    const priceInWei = ethers.parseEther(totalPrice.toString())
    
    // è°ƒç”¨æ™ºèƒ½åˆçº¦ï¼Œå‘é€ETH
    const tx = await contract.buyCredit(listingId, {
      value: priceInWei  // å‘é€çš„ETHæ•°é‡
    })
    
    const receipt = await tx.wait()
    
    console.log('ç¢³ä¿¡ç”¨è´­ä¹°æˆåŠŸ:', {
      transactionHash: receipt.hash,
      listingId: listingId,
      paidAmount: totalPrice
    })
    
    return receipt
  } catch (error) {
    console.error('è´­ä¹°å¤±è´¥:', error)
    throw error
  }
}
```

### 2.3 æŸ¥è¯¢åŠŸèƒ½

#### 2.3.1 è·å–æ‰€æœ‰ä¸Šæ¶ä¿¡æ¯ (getAllListings)

```solidity
/**
 * @dev è·å–æ‰€æœ‰çš„ç¢³ä¿¡ç”¨ä¸Šæ¶ä¿¡æ¯
 * @return æ‰€æœ‰ä¸Šæ¶ä¿¡æ¯çš„æ•°ç»„
 */
function getAllListings() public view returns (CreditListing[] memory) {
    return listings;
}
```

#### å‰ç«¯è°ƒç”¨ç¤ºä¾‹
```typescript
const getAllListings = async () => {
  try {
    const listings = await contract.getAllListings()
    
    // æ ¼å¼åŒ–æ•°æ®å¹¶è¿‡æ»¤æ´»è·ƒçš„ä¸Šæ¶ä¿¡æ¯
    return listings
      .map((listing, index) => ({
        id: index,
        seller: listing.seller,
        amount: ethers.formatEther(listing.amount),
        price: ethers.formatEther(listing.price),
        active: listing.active
      }))
      .filter(listing => listing.active)  // åªæ˜¾ç¤ºä»ç„¶æœ‰æ•ˆçš„ä¸Šæ¶ä¿¡æ¯
  } catch (error) {
    console.error('è·å–å¸‚åœºæ•°æ®å¤±è´¥:', error)
    return []
  }
}
```

#### 2.3.2 è·å–ç”¨æˆ·ä½™é¢ (balanceOf)

```solidity
// ç”¨æˆ·ç¢³ä¿¡ç”¨ä½™é¢æ˜ å°„
mapping(address => uint256) public carbonCredits;

/**
 * @dev è·å–æŒ‡å®šåœ°å€çš„ç¢³ä¿¡ç”¨ä½™é¢
 * @param account è¦æŸ¥è¯¢çš„åœ°å€
 * @return ç¢³ä¿¡ç”¨ä½™é¢
 */
function balanceOf(address account) public view returns (uint256) {
    return carbonCredits[account];
}
```

#### å‰ç«¯è°ƒç”¨ç¤ºä¾‹
```typescript
const getUserBalance = async (userAddress: string) => {
  try {
    const balance = await contract.balanceOf(userAddress)
    return ethers.formatEther(balance)
  } catch (error) {
    console.error('è·å–ä½™é¢å¤±è´¥:', error)
    return '0'
  }
}
```

## 3. äº‹ä»¶ç›‘å¬æœºåˆ¶åˆ†æ

### 3.1 äº‹ä»¶å®šä¹‰åˆ†æ

```solidity
// æ’æ”¾è®°å½•äº‹ä»¶
event EmissionRecorded(
    address indexed user,    // ç´¢å¼•å­—æ®µï¼Œä¾¿äºè¿‡æ»¤
    uint256 amount,         // æ’æ”¾é‡
    string activity         // æ´»åŠ¨ç±»å‹
);

// ç¢³ä¿¡ç”¨è´­ä¹°äº‹ä»¶
event CreditPurchased(
    address indexed buyer,   // ä¹°å®¶åœ°å€ï¼ˆç´¢å¼•ï¼‰
    address indexed seller,  // å–å®¶åœ°å€ï¼ˆç´¢å¼•ï¼‰
    uint256 amount,         // äº¤æ˜“æ•°é‡
    uint256 price           // äº¤æ˜“ä»·æ ¼
);

// ç¢³ä¿¡ç”¨ä¸Šæ¶äº‹ä»¶
event CreditListed(
    address indexed seller,  // å–å®¶åœ°å€ï¼ˆç´¢å¼•ï¼‰
    uint256 amount,         // ä¸Šæ¶æ•°é‡
    uint256 price           // å•ä»·
);
```

### 3.2 å‰ç«¯äº‹ä»¶ç›‘å¬å®ç°

```typescript
// è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
const setupEventListeners = (contract: ethers.Contract, account: string) => {
  // ç›‘å¬æ’æ”¾è®°å½•äº‹ä»¶
  const emissionFilter = contract.filters.EmissionRecorded(account)
  contract.on(emissionFilter, (user, amount, activity, event) => {
    console.log('æ–°çš„æ’æ”¾è®°å½•:', {
      user,
      amount: ethers.formatEther(amount),
      activity,
      transactionHash: event.transactionHash,
      blockNumber: event.blockNumber
    })
    
    // æ›´æ–°UIçŠ¶æ€
    refreshEmissionsData()
  })
  
  // ç›‘å¬è´­ä¹°äº‹ä»¶ï¼ˆä½œä¸ºä¹°å®¶ï¼‰
  const buyFilter = contract.filters.CreditPurchased(account, null, null, null)
  contract.on(buyFilter, (buyer, seller, amount, price, event) => {
    console.log('è´­ä¹°æˆåŠŸ:', {
      buyer,
      seller,
      amount: ethers.formatEther(amount),
      price: ethers.formatEther(price),
      transactionHash: event.transactionHash
    })
    
    // æ›´æ–°ç”¨æˆ·ä½™é¢å’Œäº¤æ˜“å†å²
    refreshUserData()
  })
  
  // ç›‘å¬é”€å”®äº‹ä»¶ï¼ˆä½œä¸ºå–å®¶ï¼‰
  const sellFilter = contract.filters.CreditPurchased(null, account, null, null)
  contract.on(sellFilter, (buyer, seller, amount, price, event) => {
    console.log('é”€å”®æˆåŠŸ:', {
      buyer,
      seller,
      amount: ethers.formatEther(amount),
      price: ethers.formatEther(price),
      transactionHash: event.transactionHash
    })
    
    // æ›´æ–°ç”¨æˆ·ä½™é¢å’Œäº¤æ˜“å†å²
    refreshUserData()
  })
  
  // ç›‘å¬ä¸Šæ¶äº‹ä»¶
  const listFilter = contract.filters.CreditListed(null, null, null)
  contract.on(listFilter, (seller, amount, price, event) => {
    console.log('æ–°çš„ä¸Šæ¶:', {
      seller,
      amount: ethers.formatEther(amount),
      price: ethers.formatEther(price),
      transactionHash: event.transactionHash
    })
    
    // æ›´æ–°å¸‚åœºæ•°æ®
    refreshMarketData()
  })
}

// æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
const cleanupEventListeners = (contract: ethers.Contract) => {
  contract.removeAllListeners('EmissionRecorded')
  contract.removeAllListeners('CreditPurchased')
  contract.removeAllListeners('CreditListed')
}
```

### 3.3 å†å²äº‹ä»¶æŸ¥è¯¢

```typescript
// æŸ¥è¯¢å†å²äº‹ä»¶
const getHistoricalEvents = async (contract: ethers.Contract, account: string) => {
  try {
    // è·å–è¿‡å»çš„æ’æ”¾è®°å½•äº‹ä»¶
    const emissionFilter = contract.filters.EmissionRecorded(account)
    const emissionEvents = await contract.queryFilter(emissionFilter, -10000) // æŸ¥è¯¢æœ€è¿‘10000ä¸ªåŒºå—
    
    const emissions = emissionEvents.map(event => ({
      amount: ethers.formatEther(event.args.amount),
      activity: event.args.activity,
      timestamp: event.blockNumber, // å¯ä»¥é€šè¿‡åŒºå—å·è·å–å‡†ç¡®æ—¶é—´
      transactionHash: event.transactionHash
    }))
    
    // è·å–è¿‡å»çš„äº¤æ˜“äº‹ä»¶
    const purchaseFilter = contract.filters.CreditPurchased(account, null, null, null)
    const purchaseEvents = await contract.queryFilter(purchaseFilter, -10000)
    
    const purchases = purchaseEvents.map(event => ({
      type: 'buy',
      amount: ethers.formatEther(event.args.amount),
      price: ethers.formatEther(event.args.price),
      counterparty: event.args.seller,
      transactionHash: event.transactionHash,
      blockNumber: event.blockNumber
    }))
    
    return { emissions, purchases }
  } catch (error) {
    console.error('æŸ¥è¯¢å†å²äº‹ä»¶å¤±è´¥:', error)
    return { emissions: [], purchases: [] }
  }
}
```

## 4. Gasè´¹ç”¨å’Œæ€§èƒ½åˆ†æ

### 4.1 å„æ–¹æ³•çš„Gasæ¶ˆè€—ä¼°ç®—

```typescript
// Gasè´¹ç”¨ä¼°ç®—
const estimateGasCosts = async (contract: ethers.Contract) => {
  try {
    // è®°å½•æ’æ”¾çš„Gasä¼°ç®—
    const recordEmissionGas = await contract.recordEmission.estimateGas(
      ethers.parseEther('1.5'),
      'äº¤é€šå‡ºè¡Œ'
    )
    console.log('è®°å½•æ’æ”¾ Gas ä¼°ç®—:', recordEmissionGas.toString())
    
    // ä¸Šæ¶ç¢³ä¿¡ç”¨çš„Gasä¼°ç®—
    const listCreditGas = await contract.listCredit.estimateGas(
      ethers.parseEther('10'),
      ethers.parseEther('0.1')
    )
    console.log('ä¸Šæ¶ç¢³ä¿¡ç”¨ Gas ä¼°ç®—:', listCreditGas.toString())
    
    // è´­ä¹°ç¢³ä¿¡ç”¨çš„Gasä¼°ç®—
    const buyCreditGas = await contract.buyCredit.estimateGas(0, {
      value: ethers.parseEther('1')
    })
    console.log('è´­ä¹°ç¢³ä¿¡ç”¨ Gas ä¼°ç®—:', buyCreditGas.toString())
    
  } catch (error) {
    console.error('Gasä¼°ç®—å¤±è´¥:', error)
  }
}
```

### 4.2 äº¤æ˜“ç¡®è®¤å’Œé”™è¯¯å¤„ç†

```typescript
// å®Œæ•´çš„äº¤æ˜“å¤„ç†æµç¨‹
const executeTransaction = async (
  contractMethod: () => Promise<ethers.ContractTransaction>,
  description: string
) => {
  try {
    // 1. å‘é€äº¤æ˜“
    console.log(`æ­£åœ¨å‘é€äº¤æ˜“: ${description}`)
    const tx = await contractMethod()
    console.log(`äº¤æ˜“å·²å‘é€ï¼Œå“ˆå¸Œ: ${tx.hash}`)
    
    // 2. ç­‰å¾…ç¡®è®¤
    console.log('ç­‰å¾…äº¤æ˜“ç¡®è®¤...')
    const receipt = await tx.wait()
    
    // 3. æ£€æŸ¥äº¤æ˜“çŠ¶æ€
    if (receipt.status === 1) {
      console.log(`äº¤æ˜“æˆåŠŸç¡®è®¤:`, {
        hash: receipt.hash,
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed.toString(),
        effectiveGasPrice: receipt.effectiveGasPrice?.toString()
      })
      return receipt
    } else {
      throw new Error('äº¤æ˜“å¤±è´¥')
    }
    
  } catch (error: any) {
    // 4. é”™è¯¯å¤„ç†
    console.error(`äº¤æ˜“å¤±è´¥: ${description}`, error)
    
    // è§£æå…·ä½“é”™è¯¯ç±»å‹
    if (error.code === 'INSUFFICIENT_FUNDS') {
      throw new Error('ä½™é¢ä¸è¶³ï¼Œè¯·æ£€æŸ¥ETHä½™é¢')
    } else if (error.code === 'USER_REJECTED') {
      throw new Error('ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“')
    } else if (error.message.includes('execution reverted')) {
      throw new Error('æ™ºèƒ½åˆçº¦æ‰§è¡Œå¤±è´¥ï¼Œè¯·æ£€æŸ¥å‚æ•°')
    } else {
      throw new Error(`äº¤æ˜“å¤±è´¥: ${error.message}`)
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const recordEmissionWithErrorHandling = async (amount: number, activity: string) => {
  return executeTransaction(
    () => contract.recordEmission(ethers.parseEther(amount.toString()), activity),
    `è®°å½•æ’æ”¾: ${amount} å¨ - ${activity}`
  )
}
```

## 5. å®‰å…¨æ€§åˆ†æ

### 5.1 æ™ºèƒ½åˆçº¦å®‰å…¨è€ƒè™‘

```solidity
// å®‰å…¨æ€§æ”¹è¿›å»ºè®®
contract CarbonCreditSystem {
    // 1. é‡å…¥æ”»å‡»é˜²æŠ¤
    bool private locked;
    modifier noReentrant() {
        require(!locked, "é‡å…¥æ”»å‡»æ£€æµ‹");
        locked = true;
        _;
        locked = false;
    }
    
    // 2. æƒé™æ§åˆ¶
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner, "ä»…é™æ‰€æœ‰è€…");
        _;
    }
    
    // 3. æš‚åœæœºåˆ¶
    bool public paused = false;
    modifier whenNotPaused() {
        require(!paused, "åˆçº¦å·²æš‚åœ");
        _;
    }
    
    // 4. å®‰å…¨çš„è´­ä¹°å‡½æ•°
    function buyCredit(uint256 listingId) public payable noReentrant whenNotPaused {
        require(listingId < listings.length, "æ— æ•ˆçš„ä¸Šæ¶ID");
        require(listings[listingId].active, "è¯¥ç¢³ä¿¡ç”¨å·²è¢«è´­ä¹°");
        
        CreditListing storage listing = listings[listingId];
        uint256 totalPrice = listing.amount * listing.price;
        require(msg.value >= totalPrice, "æ”¯ä»˜é‡‘é¢ä¸è¶³");
        
        // çŠ¶æ€æ›´æ–°åœ¨å¤–éƒ¨è°ƒç”¨ä¹‹å‰
        listing.active = false;
        carbonCredits[msg.sender] += listing.amount;
        
        // å¤–éƒ¨è°ƒç”¨æ”¾åœ¨æœ€å
        (bool success, ) = payable(listing.seller).call{value: totalPrice}("");
        require(success, "è½¬è´¦å¤±è´¥");
        
        // é€€è¿˜å¤šä½™é‡‘é¢
        if (msg.value > totalPrice) {
            (bool refundSuccess, ) = payable(msg.sender).call{value: msg.value - totalPrice}("");
            require(refundSuccess, "é€€æ¬¾å¤±è´¥");
        }
        
        emit CreditPurchased(msg.sender, listing.seller, listing.amount, totalPrice);
    }
}
```

### 5.2 å‰ç«¯å®‰å…¨å®è·µ

```typescript
// å‰ç«¯å®‰å…¨æ£€æŸ¥
const securityChecks = {
  // 1. éªŒè¯åˆçº¦åœ°å€
  validateContractAddress: (address: string) => {
    const expectedAddress = import.meta.env.VITE_CONTRACT_ADDRESS
    if (address.toLowerCase() !== expectedAddress.toLowerCase()) {
      throw new Error('åˆçº¦åœ°å€ä¸åŒ¹é…ï¼Œå¯èƒ½å­˜åœ¨å®‰å…¨é£é™©')
    }
  },
  
  // 2. éªŒè¯ç½‘ç»œ
  validateNetwork: (chainId: number) => {
    const expectedChainId = parseInt(import.meta.env.VITE_CHAIN_ID || '1')
    if (chainId !== expectedChainId) {
      throw new Error(`è¯·åˆ‡æ¢åˆ°æ­£ç¡®çš„ç½‘ç»œ (Chain ID: ${expectedChainId})`)
    }
  },
  
  // 3. éªŒè¯è¾“å…¥å‚æ•°
  validateAmount: (amount: number) => {
    if (amount <= 0) {
      throw new Error('æ•°é‡å¿…é¡»å¤§äº0')
    }
    if (amount > 1000000) {
      throw new Error('æ•°é‡è¿‡å¤§ï¼Œè¯·æ£€æŸ¥è¾“å…¥')
    }
  },
  
  // 4. éªŒè¯åœ°å€æ ¼å¼
  validateAddress: (address: string) => {
    if (!ethers.isAddress(address)) {
      throw new Error('æ— æ•ˆçš„ä»¥å¤ªåŠåœ°å€')
    }
  }
}

// å®‰å…¨çš„äº¤æ˜“æ‰§è¡Œ
const secureTransactionExecution = async (
  contractMethod: () => Promise<ethers.ContractTransaction>,
  validationChecks: (() => void)[]
) => {
  // æ‰§è¡Œæ‰€æœ‰å®‰å…¨æ£€æŸ¥
  validationChecks.forEach(check => check())
  
  // æ‰§è¡Œäº¤æ˜“
  return executeTransaction(contractMethod, 'å®‰å…¨äº¤æ˜“æ‰§è¡Œ')
}
```

## 6. æ€»ç»“

### æ™ºèƒ½åˆçº¦åŠŸèƒ½å®Œæ•´æ€§è¯„ä¼°

| åŠŸèƒ½æ¨¡å— | ABIå®šä¹‰ | å®ç°å¤æ‚åº¦ | å®‰å…¨æ€§ | çŠ¶æ€ |
|----------|---------|------------|--------|------|
| æ’æ”¾è®°å½• | âœ… å®Œæ•´ | ğŸŸ¡ ä¸­ç­‰ | âœ… è‰¯å¥½ | âŒ æœªè°ƒç”¨ |
| ç¢³ä¿¡ç”¨äº¤æ˜“ | âœ… å®Œæ•´ | ğŸ”´ å¤æ‚ | ğŸŸ¡ éœ€æ”¹è¿› | âŒ æœªè°ƒç”¨ |
| ä½™é¢æŸ¥è¯¢ | âœ… å®Œæ•´ | ğŸŸ¢ ç®€å• | âœ… è‰¯å¥½ | âŒ æœªè°ƒç”¨ |
| äº‹ä»¶ç›‘å¬ | âœ… å®Œæ•´ | ğŸŸ¡ ä¸­ç­‰ | âœ… è‰¯å¥½ | âŒ æœªå®ç° |

### å…³é”®å‘ç°

1. **ABIå®šä¹‰å®Œæ•´** - æ™ºèƒ½åˆçº¦æ¥å£å®šä¹‰éå¸¸å®Œæ•´ï¼Œæ¶µç›–äº†ç¢³ä¿¡ç”¨äº¤æ˜“DAppçš„æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½
2. **äº‹ä»¶è®¾è®¡åˆç†** - äº‹ä»¶å®šä¹‰åŒ…å«äº†å¿…è¦çš„ç´¢å¼•å­—æ®µï¼Œä¾¿äºå‰ç«¯ç›‘å¬å’ŒæŸ¥è¯¢
3. **æ•°æ®ç»“æ„æ¸…æ™°** - æ’æ”¾è®°å½•å’Œäº¤æ˜“åˆ—è¡¨çš„ç»“æ„è®¾è®¡åˆç†
4. **å®‰å…¨æ€§è€ƒè™‘ä¸è¶³** - ç¼ºå°‘é‡å…¥æ”»å‡»é˜²æŠ¤ã€æƒé™æ§åˆ¶ç­‰å®‰å…¨æœºåˆ¶
5. **å®é™…è°ƒç”¨ç¼ºå¤±** - æ‰€æœ‰æ™ºèƒ½åˆçº¦æ–¹æ³•éƒ½æœªè¢«å‰ç«¯å®é™…è°ƒç”¨

### æ”¹è¿›å»ºè®®

1. **ç«‹å³å¯è¡Œçš„æ”¹è¿›**
   - å¯ç”¨ç°æœ‰çš„æ™ºèƒ½åˆçº¦è°ƒç”¨ä»£ç 
   - å®ç°äº‹ä»¶ç›‘å¬æœºåˆ¶
   - æ·»åŠ åŸºæœ¬çš„é”™è¯¯å¤„ç†

2. **ä¸­æœŸæ”¹è¿›**
   - å¢å¼ºæ™ºèƒ½åˆçº¦å®‰å…¨æ€§
   - ä¼˜åŒ–Gasä½¿ç”¨æ•ˆç‡
   - å®ç°å®Œæ•´çš„æ•°æ®åŒæ­¥æœºåˆ¶

3. **é•¿æœŸæ”¹è¿›**
   - æ·»åŠ æ²»ç†æœºåˆ¶
   - å®ç°è·¨é“¾åŠŸèƒ½
   - é›†æˆé¢„è¨€æœºè·å–ç¢³ä»·æ•°æ®

è¿™ä¸ªæ™ºèƒ½åˆçº¦è®¾è®¡å±•ç°äº†è‰¯å¥½çš„æŠ€æœ¯æ¶æ„æ€è·¯ï¼Œåªéœ€è¦å°†å‰ç«¯çš„æ¨¡æ‹Ÿè°ƒç”¨æ›¿æ¢ä¸ºçœŸå®çš„åŒºå—é“¾äº¤äº’ï¼Œå°±èƒ½å®ç°å®Œæ•´çš„å»ä¸­å¿ƒåŒ–ç¢³ä¿¡ç”¨äº¤æ˜“å¹³å°ã€‚