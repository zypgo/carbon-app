# ä»£ç å®ç°è¯¦ç»†åˆ†æ

## 1. æ™ºèƒ½åˆçº¦æ¥å£å®ç°åˆ†æ

### 1.1 CarbonContractç±»å®Œæ•´å®ç°

```typescript
// src/contracts/contract.ts
import { ethers } from 'ethers'
import CarbonCreditSystemABI from './CarbonCreditSystem.json'

export class CarbonContract {
  private provider: ethers.BrowserProvider
  private contract: ethers.Contract | null = null
  private contractAddress: string

  constructor(provider: ethers.BrowserProvider) {
    this.provider = provider
    // âŒ é—®é¢˜ï¼šä½¿ç”¨ç¯å¢ƒå˜é‡ä¸­çš„åˆçº¦åœ°å€ï¼Œä½†å¯èƒ½æœªæ­£ç¡®é…ç½®
    this.contractAddress = import.meta.env.VITE_CONTRACT_ADDRESS || ''
    this.initContract()
  }

  // åˆå§‹åŒ–æ™ºèƒ½åˆçº¦å®ä¾‹
  private async initContract() {
    try {
      const signer = await this.provider.getSigner()
      // åˆ›å»ºåˆçº¦å®ä¾‹ï¼Œè¿æ¥åˆ°åŒºå—é“¾ç½‘ç»œ
      this.contract = new ethers.Contract(
        this.contractAddress,     // åˆçº¦éƒ¨ç½²åœ°å€
        CarbonCreditSystemABI,   // åˆçº¦åº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ¥å£
        signer                   // äº¤æ˜“ç­¾åè€…
      )
    } catch (error) {
      console.error('åˆçº¦åˆå§‹åŒ–å¤±è´¥:', error)
    }
  }

  // æ£€æŸ¥åˆçº¦æ˜¯å¦å·²æ­£ç¡®åˆå§‹åŒ–
  private checkContract() {
    if (!this.contract) {
      throw new Error('åˆçº¦æœªåˆå§‹åŒ–')
    }
  }

  /**
   * è®°å½•ç¢³æ’æ”¾åˆ°åŒºå—é“¾
   * @param amount æ’æ”¾é‡ï¼ˆä»¥å¨ä¸ºå•ä½ï¼‰
   * @param activity æ’æ”¾æ´»åŠ¨ç±»å‹
   * @returns äº¤æ˜“å›æ‰§
   */
  async recordEmission(amount: number, activity: string) {
    this.checkContract()
    const signer = await this.provider.getSigner()
    const contractWithSigner = this.contract!.connect(signer) as any
    
    try {
      // è°ƒç”¨æ™ºèƒ½åˆçº¦çš„recordEmissionæ–¹æ³•
      // å°†æ•°é‡è½¬æ¢ä¸ºWeiå•ä½ï¼ˆåŒºå—é“¾æ ‡å‡†å•ä½ï¼‰
      const tx = await contractWithSigner.recordEmission(
        ethers.parseEther(amount.toString()),  // è½¬æ¢ä¸ºWei
        activity                               // æ´»åŠ¨ç±»å‹å­—ç¬¦ä¸²
      )
      
      // ç­‰å¾…äº¤æ˜“è¢«çŸ¿å·¥ç¡®è®¤å¹¶å†™å…¥åŒºå—é“¾
      const receipt = await tx.wait()
      console.log('æ’æ”¾è®°å½•å·²ä¸Šé“¾ï¼Œäº¤æ˜“å“ˆå¸Œ:', receipt.hash)
      
      return receipt
    } catch (error) {
      console.error('è®°å½•æ’æ”¾å¤±è´¥:', error)
      throw error
    }
  }

  /**
   * ä»åŒºå—é“¾è·å–ç”¨æˆ·çš„æ’æ”¾è®°å½•
   * @returns ç”¨æˆ·çš„æ‰€æœ‰æ’æ”¾è®°å½•
   */
  async getUserEmissions() {
    this.checkContract()
    
    try {
      // è°ƒç”¨æ™ºèƒ½åˆçº¦çš„åªè¯»æ–¹æ³•è·å–æ•°æ®
      const emissions = await this.contract!.getUserEmissions()
      
      // å°†é“¾ä¸Šæ•°æ®æ ¼å¼åŒ–ä¸ºå‰ç«¯å¯ç”¨çš„æ ¼å¼
      return emissions.map((emission: any) => ({
        amount: ethers.formatEther(emission.amount),  // ä»Weiè½¬æ¢ä¸ºEther
        timestamp: Number(emission.timestamp),        // åŒºå—é“¾æ—¶é—´æˆ³
        activity: emission.activity                   // æ´»åŠ¨ç±»å‹
      }))
    } catch (error) {
      console.error('è·å–æ’æ”¾è®°å½•å¤±è´¥:', error)
      return []
    }
  }

  /**
   * åœ¨å¸‚åœºä¸Šæ¶ç¢³ä¿¡ç”¨
   * @param amount ç¢³ä¿¡ç”¨æ•°é‡
   * @param price å•ä»·ï¼ˆä»¥ETHä¸ºå•ä½ï¼‰
   * @returns äº¤æ˜“å›æ‰§
   */
  async listCredit(amount: number, price: number) {
    this.checkContract()
    const signer = await this.provider.getSigner()
    const contractWithSigner = this.contract!.connect(signer) as any
    
    try {
      // è°ƒç”¨æ™ºèƒ½åˆçº¦çš„listCreditæ–¹æ³•
      const tx = await contractWithSigner.listCredit(
        ethers.parseEther(amount.toString()),  // ç¢³ä¿¡ç”¨æ•°é‡
        ethers.parseEther(price.toString())    // å•ä»·
      )
      
      const receipt = await tx.wait()
      console.log('ç¢³ä¿¡ç”¨å·²ä¸Šæ¶ï¼Œäº¤æ˜“å“ˆå¸Œ:', receipt.hash)
      
      return receipt
    } catch (error) {
      console.error('ä¸Šæ¶ç¢³ä¿¡ç”¨å¤±è´¥:', error)
      throw error
    }
  }

  /**
   * è´­ä¹°ç¢³ä¿¡ç”¨
   * @param listingId ä¸Šæ¶ID
   * @param value æ”¯ä»˜é‡‘é¢ï¼ˆä»¥ETHä¸ºå•ä½ï¼‰
   * @returns äº¤æ˜“å›æ‰§
   */
  async buyCredit(listingId: number, value: number) {
    this.checkContract()
    const signer = await this.provider.getSigner()
    const contractWithSigner = this.contract!.connect(signer) as any
    
    try {
      // è°ƒç”¨æ™ºèƒ½åˆçº¦çš„buyCreditæ–¹æ³•ï¼Œå¹¶å‘é€ETH
      const tx = await contractWithSigner.buyCredit(listingId, {
        value: ethers.parseEther(value.toString())  // æ”¯ä»˜çš„ETHæ•°é‡
      })
      
      const receipt = await tx.wait()
      console.log('ç¢³ä¿¡ç”¨è´­ä¹°æˆåŠŸï¼Œäº¤æ˜“å“ˆå¸Œ:', receipt.hash)
      
      return receipt
    } catch (error) {
      console.error('è´­ä¹°ç¢³ä¿¡ç”¨å¤±è´¥:', error)
      throw error
    }
  }

  /**
   * è·å–å¸‚åœºä¸Šæ‰€æœ‰çš„ç¢³ä¿¡ç”¨ä¸Šæ¶ä¿¡æ¯
   * @returns æ‰€æœ‰ä¸Šæ¶çš„ç¢³ä¿¡ç”¨åˆ—è¡¨
   */
  async getAllListings() {
    this.checkContract()
    
    try {
      // ä»æ™ºèƒ½åˆçº¦è¯»å–æ‰€æœ‰ä¸Šæ¶ä¿¡æ¯
      const listings = await this.contract!.getAllListings()
      
      // æ ¼å¼åŒ–æ•°æ®ä¾›å‰ç«¯ä½¿ç”¨
      return listings.map((listing: any, index: number) => ({
        id: index,
        seller: listing.seller,                        // å–å®¶åœ°å€
        amount: ethers.formatEther(listing.amount),    // ç¢³ä¿¡ç”¨æ•°é‡
        price: ethers.formatEther(listing.price),      // å•ä»·
        active: listing.active                         // æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
      }))
    } catch (error) {
      console.error('è·å–å¸‚åœºæ•°æ®å¤±è´¥:', error)
      return []
    }
  }
}
```

## 2. å®é™…é¡µé¢å®ç°åˆ†æ

### 2.1 æ’æ”¾è®°å½•é¡µé¢å®ç°å¯¹æ¯”

#### å½“å‰å®ç°ï¼ˆæ¨¡æ‹Ÿæ•°æ®ï¼‰
```typescript
// src/pages/Emissions.tsx - å½“å‰çš„æ¨¡æ‹Ÿå®ç°
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault()
  
  if (!activity || !amount) {
    toast({
      title: 'è¯·å¡«å†™å®Œæ•´ä¿¡æ¯',
      status: 'warning',
      duration: 3000,
      isClosable: true,
    })
    return
  }

  try {
    setIsSubmitting(true)
    
    // âŒ é—®é¢˜ï¼šæ™ºèƒ½åˆçº¦è°ƒç”¨è¢«æ³¨é‡Šæ‰äº†
    // await contract.recordEmission(parseFloat(amount), activity)
    
    // âŒ é—®é¢˜ï¼šä½¿ç”¨setTimeoutæ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
    setTimeout(() => {
      const newEmission: EmissionRecord = {
        id: emissions.length + 1,
        activity: emissionActivities.find(a => a.value === activity)?.label || activity,
        amount: parseFloat(amount),
        timestamp: Date.now()  // âŒ ä½¿ç”¨æœ¬åœ°æ—¶é—´æˆ³ï¼Œè€ŒéåŒºå—é“¾æ—¶é—´æˆ³
      }
      
      // âŒ ä»…æ›´æ–°æœ¬åœ°çŠ¶æ€ï¼Œæ•°æ®æœªæŒä¹…åŒ–åˆ°åŒºå—é“¾
      setEmissions(prev => [newEmission, ...prev])
      
      // é‡ç½®è¡¨å•
      setActivity('')
      setAmount('')
      setIsSubmitting(false)
      
      toast({
        title: 'æ’æ”¾è®°å½•å·²æäº¤',
        description: 'æ‚¨çš„ç¢³æ’æ”¾æ•°æ®å·²æˆåŠŸè®°å½•',
        status: 'success',
        duration: 3000,
        isClosable: true,
      })
    }, 2000)  // âŒ æ¨¡æ‹Ÿ2ç§’å»¶è¿Ÿ
    
  } catch (error) {
    console.error('è®°å½•å¤±è´¥:', error)
    setIsSubmitting(false)
    toast({
      title: 'è®°å½•å¤±è´¥',
      description: 'è¯·ç¨åé‡è¯•',
      status: 'error',
      duration: 3000,
      isClosable: true,
    })
  }
}
```

#### åº”è¯¥çš„åŒºå—é“¾å®ç°
```typescript
// ä¿®æ­£åçš„åŒºå—é“¾å®ç°
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault()
  
  if (!activity || !amount) {
    toast({
      title: 'è¯·å¡«å†™å®Œæ•´ä¿¡æ¯',
      status: 'warning',
      duration: 3000,
      isClosable: true,
    })
    return
  }

  try {
    setIsSubmitting(true)
    
    // âœ… æ­£ç¡®çš„æ™ºèƒ½åˆçº¦è°ƒç”¨
    if (contract) {
      // è°ƒç”¨æ™ºèƒ½åˆçº¦è®°å½•æ’æ”¾æ•°æ®
      const tx = await contract.recordEmission(
        parseFloat(amount),  // æ’æ”¾é‡
        activity            // æ´»åŠ¨ç±»å‹
      )
      
      // ç­‰å¾…äº¤æ˜“ç¡®è®¤
      const receipt = await tx.wait()
      
      // è®°å½•äº¤æ˜“ä¿¡æ¯åˆ°æœ¬åœ°ï¼ˆç”¨äºå¿«é€Ÿæ˜¾ç¤ºï¼‰
      const transactionRecord = {
        txHash: receipt.hash,
        blockNumber: receipt.blockNumber,
        timestamp: Date.now()
      }
      
      // ä»åŒºå—é“¾é‡æ–°è·å–æœ€æ–°æ•°æ®
      await refreshEmissionsFromBlockchain()
      
      toast({
        title: 'æ’æ”¾è®°å½•å·²ä¸Šé“¾',
        description: `äº¤æ˜“å“ˆå¸Œ: ${receipt.hash.substring(0, 10)}...`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
    } else {
      throw new Error('æ™ºèƒ½åˆçº¦æœªåˆå§‹åŒ–')
    }
    
  } catch (error) {
    console.error('è®°å½•å¤±è´¥:', error)
    toast({
      title: 'è®°å½•å¤±è´¥',
      description: error.message || 'è¯·ç¨åé‡è¯•',
      status: 'error',
      duration: 3000,
      isClosable: true,
    })
  } finally {
    setIsSubmitting(false)
    // é‡ç½®è¡¨å•
    setActivity('')
    setAmount('')
  }
}

// âœ… ä»åŒºå—é“¾åˆ·æ–°æ•°æ®çš„å‡½æ•°
const refreshEmissionsFromBlockchain = async () => {
  try {
    if (contract) {
      const blockchainEmissions = await contract.getUserEmissions()
      
      // è½¬æ¢æ•°æ®æ ¼å¼
      const formattedEmissions = blockchainEmissions.map((emission: any, index: number) => ({
        id: index + 1,
        activity: emission.activity,
        amount: parseFloat(emission.amount),
        timestamp: emission.timestamp * 1000  // è½¬æ¢ä¸ºæ¯«ç§’
      }))
      
      setEmissions(formattedEmissions)
    }
  } catch (error) {
    console.error('åˆ·æ–°æ•°æ®å¤±è´¥:', error)
  }
}
```

### 2.2 å¸‚åœºäº¤æ˜“é¡µé¢å®ç°å¯¹æ¯”

#### å½“å‰å®ç°ï¼ˆç®€å•è½¬è´¦ï¼‰
```typescript
// src/pages/Market.tsx - å½“å‰çš„ç®€å•è½¬è´¦å®ç°
const handleBuy = async (listingId: number, price: number, amount: number, seller: string) => {
  if (!signer) {
    toast({
      title: 'è¯·å…ˆè¿æ¥é’±åŒ…',
      status: 'warning',
      duration: 3000,
      isClosable: true,
    })
    return
  }

  try {
    setBuyingId(listingId)
    
    // âŒ é—®é¢˜ï¼šä»…è¿›è¡Œç®€å•çš„ETHè½¬è´¦ï¼Œæœªè°ƒç”¨æ™ºèƒ½åˆçº¦
    const weiValue = ethers.parseEther(price.toString())
    const tx = {
      to: seller,      // ç›´æ¥è½¬è´¦ç»™å–å®¶åœ°å€
      value: weiValue  // è½¬è´¦é‡‘é¢
    }
    
    // å‘é€ç®€å•çš„ä»¥å¤ªåŠè½¬è´¦äº¤æ˜“
    const transaction = await signer.sendTransaction(tx)
    const receipt = await transaction.wait()
    
    // âŒ æ‰‹åŠ¨æ›´æ–°æœ¬åœ°çŠ¶æ€ï¼Œè€Œéä»åŒºå—é“¾è¯»å–
    setListings(prevListings => 
      prevListings.map(listing => 
        listing.id === listingId ? { ...listing, active: false } : listing
      )
    )
    
    // âŒ è®°å½•åˆ°æœ¬åœ°å­˜å‚¨ï¼Œè€ŒéåŒºå—é“¾
    if (account) {
      recordTransaction(account, {
        id: `buy_${Date.now()}`,
        type: 'buy',
        amount: amount,
        price: price,
        date: new Date().toISOString(),
        counterparty: seller,
        txHash: receipt.hash,
        status: 'confirmed',
        blockNumber: receipt.blockNumber
      })
    }
    
    toast({
      title: 'è´­ä¹°æˆåŠŸ',
      description: `å·²è´­ä¹° ${amount} ä¸ªç¢³ä¿¡ç”¨`,
      status: 'success',
      duration: 3000,
      isClosable: true,
    })
    
  } catch (error) {
    console.error('è´­ä¹°å¤±è´¥:', error)
    toast({
      title: 'è´­ä¹°å¤±è´¥',
      description: 'è¯·ç¨åé‡è¯•',
      status: 'error',
      duration: 3000,
      isClosable: true,
    })
  } finally {
    setBuyingId(null)
  }
}
```

#### åº”è¯¥çš„æ™ºèƒ½åˆçº¦å®ç°
```typescript
// ä¿®æ­£åçš„æ™ºèƒ½åˆçº¦äº¤æ˜“å®ç°
const handleBuy = async (listingId: number, price: number, amount: number, seller: string) => {
  if (!signer || !contract) {
    toast({
      title: 'è¯·å…ˆè¿æ¥é’±åŒ…',
      status: 'warning',
      duration: 3000,
      isClosable: true,
    })
    return
  }

  try {
    setBuyingId(listingId)
    
    // âœ… æ­£ç¡®çš„æ™ºèƒ½åˆçº¦è°ƒç”¨
    // è°ƒç”¨æ™ºèƒ½åˆçº¦çš„buyCreditæ–¹æ³•
    const tx = await contract.buyCredit(
      listingId,  // ä¸Šæ¶ID
      price       // æ”¯ä»˜é‡‘é¢
    )
    
    // ç­‰å¾…äº¤æ˜“ç¡®è®¤
    const receipt = await tx.wait()
    
    // âœ… ç›‘å¬æ™ºèƒ½åˆçº¦äº‹ä»¶
    contract.on('CreditPurchased', (buyer, seller, amount, price, event) => {
      console.log('ç¢³ä¿¡ç”¨è´­ä¹°äº‹ä»¶:', {
        buyer,
        seller, 
        amount: ethers.formatEther(amount),
        price: ethers.formatEther(price),
        transactionHash: event.transactionHash
      })
    })
    
    // âœ… ä»åŒºå—é“¾é‡æ–°è·å–æœ€æ–°çš„å¸‚åœºæ•°æ®
    await refreshMarketDataFromBlockchain()
    
    // âœ… æ›´æ–°ç”¨æˆ·çš„ç¢³ä¿¡ç”¨ä½™é¢
    await updateUserCarbonBalance()
    
    toast({
      title: 'è´­ä¹°æˆåŠŸ',
      description: `äº¤æ˜“å·²ä¸Šé“¾ï¼Œå“ˆå¸Œ: ${receipt.hash.substring(0, 10)}...`,
      status: 'success',
      duration: 5000,
      isClosable: true,
    })
    
  } catch (error) {
    console.error('è´­ä¹°å¤±è´¥:', error)
    
    // è§£æå…·ä½“çš„é”™è¯¯ä¿¡æ¯
    let errorMessage = 'è¯·ç¨åé‡è¯•'
    if (error.code === 'INSUFFICIENT_FUNDS') {
      errorMessage = 'ä½™é¢ä¸è¶³'
    } else if (error.code === 'USER_REJECTED') {
      errorMessage = 'ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“'
    } else if (error.message.includes('listing not active')) {
      errorMessage = 'è¯¥ç¢³ä¿¡ç”¨å·²è¢«è´­ä¹°'
    }
    
    toast({
      title: 'è´­ä¹°å¤±è´¥',
      description: errorMessage,
      status: 'error',
      duration: 3000,
      isClosable: true,
    })
  } finally {
    setBuyingId(null)
  }
}

// âœ… ä»åŒºå—é“¾åˆ·æ–°å¸‚åœºæ•°æ®
const refreshMarketDataFromBlockchain = async () => {
  try {
    if (contract) {
      const blockchainListings = await contract.getAllListings()
      
      // è¿‡æ»¤å‡ºä»ç„¶æ´»è·ƒçš„ä¸Šæ¶ä¿¡æ¯
      const activeListings = blockchainListings.filter(listing => listing.active)
      
      setListings(activeListings)
    }
  } catch (error) {
    console.error('åˆ·æ–°å¸‚åœºæ•°æ®å¤±è´¥:', error)
  }
}

// âœ… æ›´æ–°ç”¨æˆ·ç¢³ä¿¡ç”¨ä½™é¢
const updateUserCarbonBalance = async () => {
  try {
    if (contract && account) {
      const balance = await contract.balanceOf(account)
      const formattedBalance = ethers.formatEther(balance)
      
      // æ›´æ–°ç”¨æˆ·æ•°æ®
      const userData = getUserData(account)
      userData.carbonCredits = parseFloat(formattedBalance)
      saveUserData(account, userData)
    }
  } catch (error) {
    console.error('æ›´æ–°ä½™é¢å¤±è´¥:', error)
  }
}
```

## 3. Web3Contextå®ç°åˆ†æ

### 3.1 å½“å‰Web3Contextå®ç°
```typescript
// src/contexts/Web3Context.tsx - å½“å‰å®ç°åˆ†æ
export const Web3Provider = ({ children }: Web3ProviderProps) => {
  // çŠ¶æ€ç®¡ç†
  const [account, setAccount] = useState<string | null>(null)
  const [chainId, setChainId] = useState<number | null>(null)
  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null)
  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null)
  const [contract, setContract] = useState<any | null>(null)
  const [isConnecting, setIsConnecting] = useState(false)

  // âœ… é’±åŒ…è¿æ¥åŠŸèƒ½å®ç°æ­£ç¡®
  const connectWallet = async () => {
    if (!window.ethereum) {
      alert('è¯·å®‰è£… MetaMask!')
      return
    }

    try {
      setIsConnecting(true)
      
      // åˆ›å»ºWeb3æä¾›è€…
      const browserProvider = new ethers.BrowserProvider(window.ethereum)
      
      // è¯·æ±‚ç”¨æˆ·æˆæƒè¿æ¥é’±åŒ…
      const accounts = await browserProvider.send('eth_requestAccounts', [])
      
      if (accounts.length > 0) {
        const userAccount = accounts[0]
        const userSigner = await browserProvider.getSigner()
        const network = await browserProvider.getNetwork()
        const chainIdentifier = Number(network.chainId)
        
        // æ›´æ–°çŠ¶æ€
        setAccount(userAccount)
        setChainId(chainIdentifier)
        setProvider(browserProvider)
        setSigner(userSigner)
        
        // âœ… æ™ºèƒ½åˆçº¦å®ä¾‹åŒ–ï¼ˆæŠ€æœ¯ä¸Šæ­£ç¡®ï¼‰
        const contractAddress = import.meta.env.VITE_CONTRACT_ADDRESS
        if (contractAddress) {
          const carbonContract = new ethers.Contract(
            contractAddress,
            CarbonCreditSystemABI,
            userSigner
          )
          setContract(carbonContract)
        } else {
          console.warn('åˆçº¦åœ°å€æœªé…ç½®')
        }
      }
    } catch (error) {
      console.error('è¿æ¥é’±åŒ…å¤±è´¥:', error)
    } finally {
      setIsConnecting(false)
    }
  }

  // âœ… æ–­å¼€é’±åŒ…è¿æ¥
  const disconnectWallet = () => {
    setAccount(null)
    setChainId(null)
    setProvider(null)
    setSigner(null)
    setContract(null)
  }

  // âœ… ç›‘å¬è´¦æˆ·å˜åŒ–
  useEffect(() => {
    if (window.ethereum) {
      const handleAccountsChanged = (accounts: string[]) => {
        if (accounts.length === 0) {
          disconnectWallet()
        } else {
          setAccount(accounts[0])
        }
      }

      const handleChainChanged = (chainId: string) => {
        setChainId(parseInt(chainId, 16))
      }

      window.ethereum.on('accountsChanged', handleAccountsChanged)
      window.ethereum.on('chainChanged', handleChainChanged)

      return () => {
        window.ethereum.removeListener('accountsChanged', handleAccountsChanged)
        window.ethereum.removeListener('chainChanged', handleChainChanged)
      }
    }
  }, [])

  // âŒ ç¼ºå¤±ï¼šæ™ºèƒ½åˆçº¦äº‹ä»¶ç›‘å¬
  // useEffect(() => {
  //   if (contract) {
  //     // ç›‘å¬æ’æ”¾è®°å½•äº‹ä»¶
  //     contract.on('EmissionRecorded', (user, amount, activity, event) => {
  //       console.log('æ–°çš„æ’æ”¾è®°å½•:', { user, amount, activity })
  //       // è§¦å‘UIæ›´æ–°
  //     })
  //     
  //     // ç›‘å¬äº¤æ˜“äº‹ä»¶
  //     contract.on('CreditPurchased', (buyer, seller, amount, price, event) => {
  //       console.log('ç¢³ä¿¡ç”¨äº¤æ˜“:', { buyer, seller, amount, price })
  //       // è§¦å‘UIæ›´æ–°
  //     })
  //     
  //     return () => {
  //       contract.removeAllListeners()
  //     }
  //   }
  // }, [contract])

  const value = {
    account,
    chainId,
    provider,
    signer,
    contract,
    isConnecting,
    connectWallet,
    disconnectWallet
  }

  return (
    <Web3Context.Provider value={value}>
      {children}
    </Web3Context.Provider>
  )
}
```

## 4. æ•°æ®æœåŠ¡å±‚åˆ†æ

### 4.1 å½“å‰userDataServiceå®ç°
```typescript
// src/services/userDataService.ts - å®Œå…¨åŸºäºæœ¬åœ°å­˜å‚¨
export interface UserData {
  carbonCredits: number      // âŒ åº”è¯¥ä»åŒºå—é“¾è¯»å–
  totalEmissions: number     // âŒ åº”è¯¥ä»åŒºå—é“¾è®¡ç®—
  transactions: Transaction[] // âŒ åº”è¯¥ä»åŒºå—é“¾äº‹ä»¶è·å–
}

export interface Transaction {
  id: string
  type: 'buy' | 'sell'
  amount: number
  price: number
  date: string
  counterparty: string
  txHash?: string           // âœ… è®°å½•äº¤æ˜“å“ˆå¸Œæ˜¯æ­£ç¡®çš„
  status?: 'pending' | 'confirmed' | 'failed'
  blockNumber?: number      // âœ… è®°å½•åŒºå—å·æ˜¯æ­£ç¡®çš„
}

// âŒ é—®é¢˜ï¼šå®Œå…¨ä¾èµ–æœ¬åœ°å­˜å‚¨
export const getUserData = (account: string): UserData => {
  const storageKey = `userData_${account}`
  const storedData = localStorage.getItem(storageKey)
  
  if (storedData) {
    return JSON.parse(storedData)
  }
  
  return initUserData()
}

// âŒ é—®é¢˜ï¼šæ•°æ®ä¿å­˜åˆ°æœ¬åœ°è€ŒéåŒºå—é“¾
export const saveUserData = (account: string, data: UserData): void => {
  const storageKey = `userData_${account}`
  localStorage.setItem(storageKey, JSON.stringify(data))
}
```

### 4.2 åº”è¯¥çš„åŒºå—é“¾æ•°æ®æœåŠ¡å®ç°
```typescript
// ä¿®æ­£åçš„åŒºå—é“¾æ•°æ®æœåŠ¡
import { CarbonContract } from '../contracts/contract'

export class BlockchainDataService {
  private contract: CarbonContract
  private account: string

  constructor(contract: CarbonContract, account: string) {
    this.contract = contract
    this.account = account
  }

  /**
   * âœ… ä»åŒºå—é“¾è·å–ç”¨æˆ·ç¢³ä¿¡ç”¨ä½™é¢
   */
  async getCarbonCreditsBalance(): Promise<number> {
    try {
      const balance = await this.contract.balanceOf(this.account)
      return parseFloat(ethers.formatEther(balance))
    } catch (error) {
      console.error('è·å–ç¢³ä¿¡ç”¨ä½™é¢å¤±è´¥:', error)
      return 0
    }
  }

  /**
   * âœ… ä»åŒºå—é“¾è®¡ç®—ç”¨æˆ·æ€»æ’æ”¾é‡
   */
  async getTotalEmissions(): Promise<number> {
    try {
      const emissions = await this.contract.getUserEmissions()
      return emissions.reduce((total, emission) => {
        return total + parseFloat(emission.amount)
      }, 0)
    } catch (error) {
      console.error('è®¡ç®—æ€»æ’æ”¾é‡å¤±è´¥:', error)
      return 0
    }
  }

  /**
   * âœ… ä»åŒºå—é“¾äº‹ä»¶è·å–äº¤æ˜“å†å²
   */
  async getTransactionHistory(): Promise<Transaction[]> {
    try {
      const transactions: Transaction[] = []
      
      // è·å–è´­ä¹°äº‹ä»¶
      const purchaseFilter = this.contract.filters.CreditPurchased(this.account, null, null, null)
      const purchaseEvents = await this.contract.queryFilter(purchaseFilter)
      
      purchaseEvents.forEach(event => {
        transactions.push({
          id: event.transactionHash,
          type: 'buy',
          amount: parseFloat(ethers.formatEther(event.args.amount)),
          price: parseFloat(ethers.formatEther(event.args.price)),
          date: new Date(event.blockNumber * 1000).toISOString(),
          counterparty: event.args.seller,
          txHash: event.transactionHash,
          status: 'confirmed',
          blockNumber: event.blockNumber
        })
      })
      
      // è·å–é”€å”®äº‹ä»¶
      const saleFilter = this.contract.filters.CreditPurchased(null, this.account, null, null)
      const saleEvents = await this.contract.queryFilter(saleFilter)
      
      saleEvents.forEach(event => {
        transactions.push({
          id: event.transactionHash,
          type: 'sell',
          amount: parseFloat(ethers.formatEther(event.args.amount)),
          price: parseFloat(ethers.formatEther(event.args.price)),
          date: new Date(event.blockNumber * 1000).toISOString(),
          counterparty: event.args.buyer,
          txHash: event.transactionHash,
          status: 'confirmed',
          blockNumber: event.blockNumber
        })
      })
      
      // æŒ‰æ—¶é—´æ’åº
      return transactions.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
      
    } catch (error) {
      console.error('è·å–äº¤æ˜“å†å²å¤±è´¥:', error)
      return []
    }
  }

  /**
   * âœ… è·å–å®Œæ•´çš„ç”¨æˆ·æ•°æ®ï¼ˆä»åŒºå—é“¾ï¼‰
   */
  async getUserData(): Promise<UserData> {
    const [carbonCredits, totalEmissions, transactions] = await Promise.all([
      this.getCarbonCreditsBalance(),
      this.getTotalEmissions(),
      this.getTransactionHistory()
    ])

    return {
      carbonCredits,
      totalEmissions,
      transactions
    }
  }

  /**
   * âœ… ç›‘å¬åŒºå—é“¾äº‹ä»¶å¹¶æ›´æ–°æœ¬åœ°ç¼“å­˜
   */
  setupEventListeners(onDataUpdate: (data: UserData) => void) {
    // ç›‘å¬æ’æ”¾è®°å½•äº‹ä»¶
    this.contract.on('EmissionRecorded', async (user, amount, activity) => {
      if (user.toLowerCase() === this.account.toLowerCase()) {
        const updatedData = await this.getUserData()
        onDataUpdate(updatedData)
      }
    })

    // ç›‘å¬äº¤æ˜“äº‹ä»¶
    this.contract.on('CreditPurchased', async (buyer, seller, amount, price) => {
      if (buyer.toLowerCase() === this.account.toLowerCase() || 
          seller.toLowerCase() === this.account.toLowerCase()) {
        const updatedData = await this.getUserData()
        onDataUpdate(updatedData)
      }
    })
  }
}
```

## 5. æ€»ç»“

é€šè¿‡è¯¦ç»†çš„ä»£ç åˆ†æï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼š

### âœ… å·²æ­£ç¡®å®ç°çš„åŠŸèƒ½ï¼š
1. **Web3é’±åŒ…é›†æˆ** - MetaMaskè¿æ¥ã€è´¦æˆ·ç®¡ç†ã€ç½‘ç»œæ£€æµ‹
2. **æ™ºèƒ½åˆçº¦æ¥å£å®šä¹‰** - å®Œæ•´çš„ABIå’Œæ–¹æ³•å®šä¹‰
3. **åŸºç¡€åŒºå—é“¾äº¤äº’** - ç®€å•çš„ETHè½¬è´¦åŠŸèƒ½
4. **äº¤æ˜“çŠ¶æ€è·Ÿè¸ª** - äº¤æ˜“å“ˆå¸Œå’ŒåŒºå—å·è®°å½•

### âŒ æœªå®ç°çš„å…³é”®åŠŸèƒ½ï¼š
1. **æ™ºèƒ½åˆçº¦æ–¹æ³•è°ƒç”¨** - æ‰€æœ‰åˆçº¦æ–¹æ³•éƒ½æœªè¢«å®é™…è°ƒç”¨
2. **é“¾ä¸Šæ•°æ®è¯»å–** - æ•°æ®å®Œå…¨æ¥è‡ªæœ¬åœ°å­˜å‚¨
3. **äº‹ä»¶ç›‘å¬æœºåˆ¶** - ç¼ºå°‘åŒºå—é“¾äº‹ä»¶ç›‘å¬
4. **æ•°æ®åŒæ­¥** - æ— æ³•ä»åŒºå—é“¾åŒæ­¥æœ€æ–°çŠ¶æ€

### ğŸ”§ ä¿®å¤å»ºè®®ï¼š
1. å¯ç”¨è¢«æ³¨é‡Šçš„æ™ºèƒ½åˆçº¦è°ƒç”¨ä»£ç 
2. å®ç°åŒºå—é“¾æ•°æ®æœåŠ¡å±‚
3. æ·»åŠ äº‹ä»¶ç›‘å¬å’Œå®æ—¶æ›´æ–°æœºåˆ¶
4. éƒ¨ç½²å®é™…çš„æ™ºèƒ½åˆçº¦åˆ°æµ‹è¯•ç½‘ç»œ

è¿™ä¸ªé¡¹ç›®å…·å¤‡äº†å®Œæ•´çš„æŠ€æœ¯æ¶æ„ï¼Œåªéœ€è¦å°†æ¨¡æ‹Ÿçš„åŠŸèƒ½æ›¿æ¢ä¸ºçœŸå®çš„åŒºå—é“¾äº¤äº’å³å¯å®ç°å®Œæ•´çš„DAppåŠŸèƒ½ã€‚