# 碳交易DApp代码实现深度分析

## 概述

本文档对碳交易DApp项目的代码实现进行全面分析，包括前端架构、智能合约集成、状态管理、用户界面设计、性能优化以及部署配置等方面。项目采用现代React技术栈，结合Web3技术，实现了一个功能完整的去中心化碳信用交易平台。

## 项目架构概览

### 1. 技术栈分析

#### 前端技术栈
- **框架**: React 18.3.1 + TypeScript
- **构建工具**: Vite 5.4.10
- **样式框架**: Tailwind CSS 3.4.14
- **状态管理**: Zustand 5.0.1
- **路由**: React Router DOM 6.28.0
- **Web3集成**: Ethers.js 6.13.4
- **UI组件**: Lucide React (图标)
- **国际化**: React i18next 15.1.1
- **通知系统**: Sonner 1.7.1

#### 开发工具链
- **包管理器**: pnpm (优先) / npm
- **代码质量**: ESLint + TypeScript
- **部署**: GitHub Pages + gh-pages
- **智能合约**: Hardhat + Solidity

### 2. 项目结构分析

```
src/
├── components/          # 可复用组件
│   ├── ui/             # 基础UI组件
│   ├── layout/         # 布局组件
│   └── common/         # 通用组件
├── pages/              # 页面组件
│   ├── Market.tsx      # 碳信用市场
│   ├── Emissions.tsx   # 排放记录
│   ├── Projects.tsx    # 项目管理
│   └── Dashboard.tsx   # 仪表板
├── hooks/              # 自定义Hooks
├── utils/              # 工具函数
├── services/           # 服务层
│   ├── contractService.ts  # 智能合约服务
│   └── web3Service.ts      # Web3服务
├── contexts/           # React上下文
│   └── Web3Context.tsx # Web3上下文
├── types/              # TypeScript类型定义
├── locales/            # 国际化资源
└── assets/             # 静态资源
```

## 核心组件实现分析

### 1. Web3集成架构

#### Web3Context.tsx - Web3上下文管理

```typescript
// Web3上下文的核心实现
interface Web3ContextType {
  // 连接状态
  account: string | null;
  chainId: number | null;
  isConnected: boolean;
  
  // Web3实例
  provider: ethers.BrowserProvider | null;
  signer: ethers.JsonRpcSigner | null;
  contract: ethers.Contract | null;
  
  // 用户角色
  userRole: 'user' | 'verifier';
  
  // 操作方法
  connectWallet: () => Promise<void>;
  disconnectWallet: () => void;
  switchRole: (role: 'user' | 'verifier') => void;
}

// 合约配置
const CONTRACT_CONFIG = {
  address: "0xABCDEF1234567890ABCDEF1234567890ABCDEF12",
  chainId: 11155111, // Sepolia测试网
  rpcUrls: [
    "https://sepolia.infura.io/v3/YOUR_PROJECT_ID",
    "https://rpc.sepolia.org",
    "https://ethereum-sepolia.publicnode.com",
    "https://1rpc.io/sepolia"
  ]
};

// Web3Provider组件实现
export const Web3Provider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [account, setAccount] = useState<string | null>(null);
  const [chainId, setChainId] = useState<number | null>(null);
  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);
  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);
  const [contract, setContract] = useState<ethers.Contract | null>(null);
  const [userRole, setUserRole] = useState<'user' | 'verifier'>('user');

  // 连接钱包的核心逻辑
  const connectWallet = async () => {
    try {
      if (!window.ethereum) {
        throw new Error('请安装MetaMask钱包');
      }

      // 请求账户访问权限
      const accounts = await window.ethereum.request({
        method: 'eth_requestAccounts'
      });

      if (accounts.length === 0) {
        throw new Error('未找到可用账户');
      }

      // 创建Provider和Signer
      const web3Provider = new ethers.BrowserProvider(window.ethereum);
      const web3Signer = await web3Provider.getSigner();
      const network = await web3Provider.getNetwork();

      // 检查网络
      if (Number(network.chainId) !== CONTRACT_CONFIG.chainId) {
        await switchToSepoliaNetwork();
        return;
      }

      // 创建合约实例
      const contractInstance = new ethers.Contract(
        CONTRACT_CONFIG.address,
        CarbonCreditSystemABI,
        web3Signer
      );

      // 更新状态
      setAccount(accounts[0]);
      setChainId(Number(network.chainId));
      setProvider(web3Provider);
      setSigner(web3Signer);
      setContract(contractInstance);

      console.log('钱包连接成功:', {
        account: accounts[0],
        chainId: Number(network.chainId),
        contractAddress: CONTRACT_CONFIG.address
      });

    } catch (error) {
      console.error('连接钱包失败:', error);
      throw error;
    }
  };

  // 网络切换逻辑
  const switchToSepoliaNetwork = async () => {
    try {
      await window.ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: `0x${CONTRACT_CONFIG.chainId.toString(16)}` }]
      });
    } catch (switchError: any) {
      // 如果网络不存在，添加网络
      if (switchError.code === 4902) {
        await window.ethereum.request({
          method: 'wallet_addEthereumChain',
          params: [{
            chainId: `0x${CONTRACT_CONFIG.chainId.toString(16)}`,
            chainName: 'Sepolia Test Network',
            nativeCurrency: {
              name: 'SepoliaETH',
              symbol: 'SEP',
              decimals: 18
            },
            rpcUrls: CONTRACT_CONFIG.rpcUrls,
            blockExplorerUrls: ['https://sepolia.etherscan.io/']
          }]
        });
      }
    }
  };

  // 监听账户和网络变化
  useEffect(() => {
    if (window.ethereum) {
      const handleAccountsChanged = (accounts: string[]) => {
        if (accounts.length === 0) {
          disconnectWallet();
        } else {
          setAccount(accounts[0]);
        }
      };

      const handleChainChanged = (chainId: string) => {
        const newChainId = parseInt(chainId, 16);
        setChainId(newChainId);
        
        if (newChainId !== CONTRACT_CONFIG.chainId) {
          console.warn('网络已切换，请切换回Sepolia测试网');
        }
      };

      window.ethereum.on('accountsChanged', handleAccountsChanged);
      window.ethereum.on('chainChanged', handleChainChanged);

      return () => {
        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
        window.ethereum.removeListener('chainChanged', handleChainChanged);
      };
    }
  }, []);

  const value: Web3ContextType = {
    account,
    chainId,
    isConnected: !!account && chainId === CONTRACT_CONFIG.chainId,
    provider,
    signer,
    contract,
    userRole,
    connectWallet,
    disconnectWallet,
    switchRole: setUserRole
  };

  return (
    <Web3Context.Provider value={value}>
      {children}
    </Web3Context.Provider>
  );
};
```

### 2. 智能合约服务层

#### contractService.ts - 合约交互服务

```typescript
// 数据接口定义
interface EmissionRecord {
  id: number;
  user: string;
  amount: number;
  activityType: string;
  timestamp: number;
  verified: boolean;
  verifier?: string;
}

interface Project {
  id: number;
  name: string;
  description: string;
  projectType: string;
  totalCredits: number;
  provider: string;
  status: 'Pending' | 'Approved' | 'Rejected';
  createdAt: number;
  verifier?: string;
  reviewNotes?: string;
}

interface CreditListing {
  id: number;
  seller: string;
  amount: number;
  pricePerCredit: number;
  active: boolean;
  timestamp: number;
  projectId: number;
}

interface Transaction {
  id: string;
  type: 'emission' | 'purchase' | 'listing' | 'project';
  amount: number;
  timestamp: number;
  status: 'pending' | 'confirmed' | 'failed';
  hash?: string;
  blockNumber?: number;
}

// 合约服务类
class ContractService {
  private contract: ethers.Contract | null = null;
  private signer: ethers.JsonRpcSigner | null = null;

  constructor(contract: ethers.Contract | null, signer: ethers.JsonRpcSigner | null) {
    this.contract = contract;
    this.signer = signer;
  }

  // 排放记录相关方法
  async recordEmission(amount: number, activityType: string): Promise<Transaction> {
    if (!this.contract || !this.signer) {
      throw new Error('合约未初始化');
    }

    try {
      console.log('记录排放:', { amount, activityType });
      
      // 调用智能合约方法
      const tx = await this.contract.recordEmission(
        ethers.parseUnits(amount.toString(), 18), // 转换为Wei
        activityType
      );

      console.log('交易已发送:', tx.hash);

      // 等待交易确认
      const receipt = await tx.wait();
      
      console.log('交易已确认:', {
        hash: receipt.hash,
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed.toString()
      });

      return {
        id: tx.hash,
        type: 'emission',
        amount,
        timestamp: Date.now(),
        status: 'confirmed',
        hash: receipt.hash,
        blockNumber: receipt.blockNumber
      };

    } catch (error) {
      console.error('记录排放失败:', error);
      throw this.handleContractError(error);
    }
  }

  async getUserEmissions(userAddress: string): Promise<EmissionRecord[]> {
    if (!this.contract) {
      throw new Error('合约未初始化');
    }

    try {
      console.log('获取用户排放记录:', userAddress);
      
      const emissions = await this.contract.getUserEmissions(userAddress);
      
      return emissions.map((emission: any, index: number) => ({
        id: index,
        user: userAddress,
        amount: Number(ethers.formatUnits(emission.amount, 18)),
        activityType: emission.activityType,
        timestamp: Number(emission.timestamp) * 1000,
        verified: emission.verified,
        verifier: emission.verifier !== ethers.ZeroAddress ? emission.verifier : undefined
      }));

    } catch (error) {
      console.error('获取排放记录失败:', error);
      throw this.handleContractError(error);
    }
  }

  async verifyEmission(emissionId: number): Promise<Transaction> {
    if (!this.contract || !this.signer) {
      throw new Error('合约未初始化');
    }

    try {
      console.log('验证排放记录:', emissionId);
      
      const tx = await this.contract.verifyEmission(emissionId);
      const receipt = await tx.wait();
      
      console.log('排放记录验证成功:', receipt.hash);

      return {
        id: tx.hash,
        type: 'emission',
        amount: 0,
        timestamp: Date.now(),
        status: 'confirmed',
        hash: receipt.hash,
        blockNumber: receipt.blockNumber
      };

    } catch (error) {
      console.error('验证排放记录失败:', error);
      throw this.handleContractError(error);
    }
  }

  // 项目管理相关方法
  async submitProject(
    name: string,
    description: string,
    projectType: string,
    expectedCredits: number
  ): Promise<Transaction> {
    if (!this.contract || !this.signer) {
      throw new Error('合约未初始化');
    }

    try {
      console.log('提交项目:', { name, description, projectType, expectedCredits });
      
      const tx = await this.contract.createProject(
        name,
        description,
        projectType,
        expectedCredits
      );

      const receipt = await tx.wait();
      
      console.log('项目提交成功:', receipt.hash);

      return {
        id: tx.hash,
        type: 'project',
        amount: expectedCredits,
        timestamp: Date.now(),
        status: 'confirmed',
        hash: receipt.hash,
        blockNumber: receipt.blockNumber
      };

    } catch (error) {
      console.error('提交项目失败:', error);
      throw this.handleContractError(error);
    }
  }

  async getAllProjects(): Promise<Project[]> {
    if (!this.contract) {
      throw new Error('合约未初始化');
    }

    try {
      console.log('获取所有项目');
      
      const projectIds = await this.contract.getAllProjectIds();
      const projects: Project[] = [];

      for (const id of projectIds) {
        const project = await this.contract.projects(id);
        projects.push({
          id: Number(id),
          name: project.name,
          description: project.description,
          projectType: project.projectType,
          totalCredits: Number(project.totalCredits),
          provider: project.provider,
          status: ['Pending', 'Approved', 'Rejected'][project.status],
          createdAt: Number(project.createdAt) * 1000,
          verifier: project.verifier !== ethers.ZeroAddress ? project.verifier : undefined,
          reviewNotes: project.reviewNotes || undefined
        });
      }

      return projects;

    } catch (error) {
      console.error('获取项目列表失败:', error);
      throw this.handleContractError(error);
    }
  }

  async reviewProject(
    projectId: number,
    approved: boolean,
    reviewNotes: string
  ): Promise<Transaction> {
    if (!this.contract || !this.signer) {
      throw new Error('合约未初始化');
    }

    try {
      console.log('审核项目:', { projectId, approved, reviewNotes });
      
      const tx = await this.contract.reviewProject(projectId, approved, reviewNotes);
      const receipt = await tx.wait();
      
      console.log('项目审核完成:', receipt.hash);

      return {
        id: tx.hash,
        type: 'project',
        amount: 0,
        timestamp: Date.now(),
        status: 'confirmed',
        hash: receipt.hash,
        blockNumber: receipt.blockNumber
      };

    } catch (error) {
      console.error('审核项目失败:', error);
      throw this.handleContractError(error);
    }
  }

  // 市场交易相关方法
  async listCredit(
    amount: number,
    pricePerCredit: number,
    projectId: number
  ): Promise<Transaction> {
    if (!this.contract || !this.signer) {
      throw new Error('合约未初始化');
    }

    try {
      console.log('上架碳信用:', { amount, pricePerCredit, projectId });
      
      const tx = await this.contract.listCredit(
        amount,
        ethers.parseEther(pricePerCredit.toString()),
        projectId
      );

      const receipt = await tx.wait();
      
      console.log('碳信用上架成功:', receipt.hash);

      return {
        id: tx.hash,
        type: 'listing',
        amount,
        timestamp: Date.now(),
        status: 'confirmed',
        hash: receipt.hash,
        blockNumber: receipt.blockNumber
      };

    } catch (error) {
      console.error('上架碳信用失败:', error);
      throw this.handleContractError(error);
    }
  }

  async buyCredit(listingId: number, amount: number, totalPrice: number): Promise<Transaction> {
    if (!this.contract || !this.signer) {
      throw new Error('合约未初始化');
    }

    try {
      console.log('购买碳信用:', { listingId, amount, totalPrice });
      
      const tx = await this.contract.buyCredit(listingId, amount, {
        value: ethers.parseEther(totalPrice.toString())
      });

      const receipt = await tx.wait();
      
      console.log('碳信用购买成功:', receipt.hash);

      return {
        id: tx.hash,
        type: 'purchase',
        amount,
        timestamp: Date.now(),
        status: 'confirmed',
        hash: receipt.hash,
        blockNumber: receipt.blockNumber
      };

    } catch (error) {
      console.error('购买碳信用失败:', error);
      throw this.handleContractError(error);
    }
  }

  async getAllListings(): Promise<CreditListing[]> {
    if (!this.contract) {
      throw new Error('合约未初始化');
    }

    try {
      console.log('获取所有挂单');
      
      const listings = await this.contract.getAllListings();
      
      return listings.map((listing: any, index: number) => ({
        id: index,
        seller: listing.seller,
        amount: Number(listing.amount),
        pricePerCredit: Number(ethers.formatEther(listing.pricePerCredit)),
        active: listing.active,
        timestamp: Number(listing.timestamp) * 1000,
        projectId: Number(listing.projectId)
      }));

    } catch (error) {
      console.error('获取挂单列表失败:', error);
      throw this.handleContractError(error);
    }
  }

  // 余额查询
  async getUserBalance(userAddress: string): Promise<number> {
    if (!this.contract) {
      throw new Error('合约未初始化');
    }

    try {
      const balance = await this.contract.carbonCredits(userAddress);
      return Number(balance);
    } catch (error) {
      console.error('获取用户余额失败:', error);
      return 0;
    }
  }

  // 错误处理
  private handleContractError(error: any): Error {
    if (error.code === 'INSUFFICIENT_FUNDS') {
      return new Error('余额不足，请检查ETH余额');
    } else if (error.code === 'USER_REJECTED') {
      return new Error('用户取消了交易');
    } else if (error.message?.includes('execution reverted')) {
      return new Error('智能合约执行失败，请检查参数');
    } else if (error.message?.includes('network')) {
      return new Error('网络连接失败，请检查网络设置');
    } else {
      return new Error(`交易失败: ${error.message || '未知错误'}`);
    }
  }
}

export default ContractService;
```

### 3. 页面组件实现分析

#### Market.tsx - 碳信用市场页面

```typescript
// 市场页面的核心实现
const Market: React.FC = () => {
  const { t } = useTranslation();
  const { contract, account, isConnected } = useWeb3();
  
  // 状态管理
  const [listings, setListings] = useState<CreditListing[]>([]);
  const [userBalance, setUserBalance] = useState<number>(0);
  const [loading, setLoading] = useState(false);
  const [showCreateListing, setShowCreateListing] = useState(false);
  
  // 表单状态
  const [newListing, setNewListing] = useState({
    amount: '',
    price: '',
    projectId: ''
  });

  // 合约服务实例
  const contractService = useMemo(() => {
    if (contract && account) {
      return new ContractService(contract, contract.signer);
    }
    return null;
  }, [contract, account]);

  // 加载市场数据
  const loadMarketData = useCallback(async () => {
    if (!contractService) return;

    try {
      setLoading(true);
      
      // 并行加载数据
      const [marketListings, balance] = await Promise.all([
        contractService.getAllListings(),
        account ? contractService.getUserBalance(account) : Promise.resolve(0)
      ]);

      setListings(marketListings.filter(listing => listing.active));
      setUserBalance(balance);
      
    } catch (error) {
      console.error('加载市场数据失败:', error);
      toast.error(t('market.loadError'));
    } finally {
      setLoading(false);
    }
  }, [contractService, account, t]);

  // 购买碳信用
  const handleBuyCredit = async (listing: CreditListing, amount: number) => {
    if (!contractService || !account) {
      toast.error(t('common.connectWallet'));
      return;
    }

    try {
      setLoading(true);
      
      const totalPrice = amount * listing.pricePerCredit;
      
      // 确认购买
      const confirmed = await showConfirmDialog({
        title: t('market.confirmPurchase'),
        message: t('market.purchaseDetails', {
          amount,
          price: totalPrice.toFixed(4),
          seller: listing.seller
        })
      });

      if (!confirmed) return;

      // 执行购买交易
      const transaction = await contractService.buyCredit(
        listing.id,
        amount,
        totalPrice
      );

      toast.success(t('market.purchaseSuccess', {
        hash: transaction.hash?.slice(0, 10) + '...'
      }));

      // 刷新数据
      await loadMarketData();
      
    } catch (error: any) {
      console.error('购买失败:', error);
      toast.error(error.message || t('market.purchaseError'));
    } finally {
      setLoading(false);
    }
  };

  // 创建新挂单
  const handleCreateListing = async () => {
    if (!contractService || !account) {
      toast.error(t('common.connectWallet'));
      return;
    }

    try {
      setLoading(true);
      
      const { amount, price, projectId } = newListing;
      
      // 验证输入
      if (!amount || !price || !projectId) {
        toast.error(t('market.fillAllFields'));
        return;
      }

      const numAmount = Number(amount);
      const numPrice = Number(price);
      const numProjectId = Number(projectId);

      if (numAmount <= 0 || numPrice <= 0) {
        toast.error(t('market.invalidAmount'));
        return;
      }

      if (numAmount > userBalance) {
        toast.error(t('market.insufficientBalance'));
        return;
      }

      // 执行上架交易
      const transaction = await contractService.listCredit(
        numAmount,
        numPrice,
        numProjectId
      );

      toast.success(t('market.listingSuccess', {
        hash: transaction.hash?.slice(0, 10) + '...'
      }));

      // 重置表单并刷新数据
      setNewListing({ amount: '', price: '', projectId: '' });
      setShowCreateListing(false);
      await loadMarketData();
      
    } catch (error: any) {
      console.error('创建挂单失败:', error);
      toast.error(error.message || t('market.listingError'));
    } finally {
      setLoading(false);
    }
  };

  // 初始化加载
  useEffect(() => {
    if (isConnected) {
      loadMarketData();
    }
  }, [isConnected, loadMarketData]);

  // 渲染组件
  return (
    <div className="container mx-auto px-4 py-8">
      {/* 页面标题和用户余额 */}
      <div className="flex justify-between items-center mb-8">
        <div>
          <h1 className="text-3xl font-bold text-gray-900 dark:text-white">
            {t('market.title')}
          </h1>
          <p className="text-gray-600 dark:text-gray-400 mt-2">
            {t('market.description')}
          </p>
        </div>
        
        {isConnected && (
          <div className="text-right">
            <div className="text-sm text-gray-600 dark:text-gray-400">
              {t('market.yourBalance')}
            </div>
            <div className="text-2xl font-bold text-green-600">
              {userBalance.toLocaleString()} {t('common.credits')}
            </div>
          </div>
        )}
      </div>

      {/* 操作按钮 */}
      {isConnected && userBalance > 0 && (
        <div className="mb-6">
          <button
            onClick={() => setShowCreateListing(true)}
            className="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg transition-colors"
            disabled={loading}
          >
            <Plus className="w-4 h-4 inline mr-2" />
            {t('market.createListing')}
          </button>
        </div>
      )}

      {/* 市场列表 */}
      {loading ? (
        <div className="flex justify-center items-center py-12">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
          <span className="ml-2 text-gray-600">{t('common.loading')}</span>
        </div>
      ) : listings.length === 0 ? (
        <div className="text-center py-12">
          <ShoppingCart className="w-16 h-16 text-gray-400 mx-auto mb-4" />
          <h3 className="text-xl font-semibold text-gray-600 mb-2">
            {t('market.noListings')}
          </h3>
          <p className="text-gray-500">
            {t('market.noListingsDescription')}
          </p>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {listings.map((listing) => (
            <CreditListingCard
              key={listing.id}
              listing={listing}
              onBuy={handleBuyCredit}
              disabled={loading || listing.seller === account}
            />
          ))}
        </div>
      )}

      {/* 创建挂单模态框 */}
      {showCreateListing && (
        <CreateListingModal
          listing={newListing}
          onChange={setNewListing}
          onSubmit={handleCreateListing}
          onClose={() => setShowCreateListing(false)}
          loading={loading}
          maxAmount={userBalance}
        />
      )}
    </div>
  );
};

export default Market;
```

#### Emissions.tsx - 排放记录页面

```typescript
// 排放记录页面的核心实现
const Emissions: React.FC = () => {
  const { t } = useTranslation();
  const { contract, account, isConnected, userRole } = useWeb3();
  
  // 状态管理
  const [emissions, setEmissions] = useState<EmissionRecord[]>([]);
  const [loading, setLoading] = useState(false);
  const [showAddEmission, setShowAddEmission] = useState(false);
  const [isVerifier, setIsVerifier] = useState(false);
  
  // 表单状态
  const [newEmission, setNewEmission] = useState({
    amount: '',
    activityType: ''
  });

  // 合约服务实例
  const contractService = useMemo(() => {
    if (contract && account) {
      return new ContractService(contract, contract.signer);
    }
    return null;
  }, [contract, account]);

  // 检查用户是否为验证者
  const checkVerifierRole = useCallback(async () => {
    if (!contract || !account) return;

    try {
      const VERIFIER_ROLE = await contract.VERIFIER_ROLE();
      const hasRole = await contract.hasRole(VERIFIER_ROLE, account);
      setIsVerifier(hasRole);
    } catch (error) {
      console.error('检查验证者角色失败:', error);
      setIsVerifier(false);
    }
  }, [contract, account]);

  // 加载排放记录
  const loadEmissions = useCallback(async () => {
    if (!contractService || !account) return;

    try {
      setLoading(true);
      
      const userEmissions = await contractService.getUserEmissions(account);
      setEmissions(userEmissions.sort((a, b) => b.timestamp - a.timestamp));
      
    } catch (error) {
      console.error('加载排放记录失败:', error);
      toast.error(t('emissions.loadError'));
    } finally {
      setLoading(false);
    }
  }, [contractService, account, t]);

  // 记录新排放
  const handleAddEmission = async () => {
    if (!contractService || !account) {
      toast.error(t('common.connectWallet'));
      return;
    }

    try {
      setLoading(true);
      
      const { amount, activityType } = newEmission;
      
      // 验证输入
      if (!amount || !activityType) {
        toast.error(t('emissions.fillAllFields'));
        return;
      }

      const numAmount = Number(amount);
      if (numAmount <= 0) {
        toast.error(t('emissions.invalidAmount'));
        return;
      }

      // 执行记录交易
      const transaction = await contractService.recordEmission(
        numAmount,
        activityType
      );

      toast.success(t('emissions.recordSuccess', {
        hash: transaction.hash?.slice(0, 10) + '...'
      }));

      // 重置表单并刷新数据
      setNewEmission({ amount: '', activityType: '' });
      setShowAddEmission(false);
      await loadEmissions();
      
    } catch (error: any) {
      console.error('记录排放失败:', error);
      toast.error(error.message || t('emissions.recordError'));
    } finally {
      setLoading(false);
    }
  };

  // 验证排放记录
  const handleVerifyEmission = async (emissionId: number) => {
    if (!contractService || !isVerifier) {
      toast.error(t('emissions.verifierOnly'));
      return;
    }

    try {
      setLoading(true);
      
      // 确认验证
      const confirmed = await showConfirmDialog({
        title: t('emissions.confirmVerify'),
        message: t('emissions.verifyDetails', { id: emissionId })
      });

      if (!confirmed) return;

      // 执行验证交易
      const transaction = await contractService.verifyEmission(emissionId);

      toast.success(t('emissions.verifySuccess', {
        hash: transaction.hash?.slice(0, 10) + '...'
      }));

      // 刷新数据
      await loadEmissions();
      
    } catch (error: any) {
      console.error('验证排放记录失败:', error);
      toast.error(error.message || t('emissions.verifyError'));
    } finally {
      setLoading(false);
    }
  };

  // 初始化加载
  useEffect(() => {
    if (isConnected) {
      loadEmissions();
      checkVerifierRole();
    }
  }, [isConnected, loadEmissions, checkVerifierRole]);

  // 渲染组件
  return (
    <div className="container mx-auto px-4 py-8">
      {/* 页面标题和统计 */}
      <div className="flex justify-between items-center mb-8">
        <div>
          <h1 className="text-3xl font-bold text-gray-900 dark:text-white">
            {t('emissions.title')}
          </h1>
          <p className="text-gray-600 dark:text-gray-400 mt-2">
            {t('emissions.description')}
          </p>
        </div>
        
        {isConnected && (
          <div className="text-right">
            <div className="text-sm text-gray-600 dark:text-gray-400">
              {t('emissions.totalRecords')}
            </div>
            <div className="text-2xl font-bold text-red-600">
              {emissions.length}
            </div>
          </div>
        )}
      </div>

      {/* 操作按钮 */}
      {isConnected && (
        <div className="mb-6 flex gap-4">
          <button
            onClick={() => setShowAddEmission(true)}
            className="bg-red-600 hover:bg-red-700 text-white px-6 py-2 rounded-lg transition-colors"
            disabled={loading}
          >
            <Plus className="w-4 h-4 inline mr-2" />
            {t('emissions.addRecord')}
          </button>
          
          {isVerifier && (
            <div className="flex items-center text-sm text-blue-600">
              <Shield className="w-4 h-4 mr-1" />
              {t('emissions.verifierMode')}
            </div>
          )}
        </div>
      )}

      {/* 排放记录列表 */}
      {loading ? (
        <div className="flex justify-center items-center py-12">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600"></div>
          <span className="ml-2 text-gray-600">{t('common.loading')}</span>
        </div>
      ) : emissions.length === 0 ? (
        <div className="text-center py-12">
          <Activity className="w-16 h-16 text-gray-400 mx-auto mb-4" />
          <h3 className="text-xl font-semibold text-gray-600 mb-2">
            {t('emissions.noRecords')}
          </h3>
          <p className="text-gray-500">
            {t('emissions.noRecordsDescription')}
          </p>
        </div>
      ) : (
        <div className="space-y-4">
          {emissions.map((emission) => (
            <EmissionRecordCard
              key={emission.id}
              emission={emission}
              onVerify={isVerifier ? handleVerifyEmission : undefined}
              disabled={loading}
            />
          ))}
        </div>
      )}

      {/* 添加排放记录模态框 */}
      {showAddEmission && (
        <AddEmissionModal
          emission={newEmission}
          onChange={setNewEmission}
          onSubmit={handleAddEmission}
          onClose={() => setShowAddEmission(false)}
          loading={loading}
        />
      )}
    </div>
  );
};

export default Emissions;
```

### 4. 状态管理实现

#### Zustand状态管理

```typescript
// stores/appStore.ts - 应用状态管理
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface AppState {
  // UI状态
  theme: 'light' | 'dark';
  language: string;
  sidebarOpen: boolean;
  
  // 用户数据
  userProfile: {
    address: string | null;
    role: 'user' | 'verifier';
    balance: number;
    totalEmissions: number;
    totalCredits: number;
  };
  
  // 应用数据
  notifications: Notification[];
  transactions: Transaction[];
  
  // 操作方法
  setTheme: (theme: 'light' | 'dark') => void;
  setLanguage: (language: string) => void;
  toggleSidebar: () => void;
  updateUserProfile: (profile: Partial<AppState['userProfile']>) => void;
  addNotification: (notification: Omit<Notification, 'id'>) => void;
  removeNotification: (id: string) => void;
  addTransaction: (transaction: Transaction) => void;
  clearTransactions: () => void;
}

const useAppStore = create<AppState>()(n  persist(
    (set, get) => ({
      // 初始状态
      theme: 'light',
      language: 'zh',
      sidebarOpen: false,
      userProfile: {
        address: null,
        role: 'user',
        balance: 0,
        totalEmissions: 0,
        totalCredits: 0
      },
      notifications: [],
      transactions: [],

      // 操作方法
      setTheme: (theme) => set({ theme }),
      
      setLanguage: (language) => set({ language }),
      
      toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
      
      updateUserProfile: (profile) => set((state) => ({
        userProfile: { ...state.userProfile, ...profile }
      })),
      
      addNotification: (notification) => set((state) => ({
        notifications: [
          ...state.notifications,
          { ...notification, id: Date.now().toString() }
        ]
      })),
      
      removeNotification: (id) => set((state) => ({
        notifications: state.notifications.filter(n => n.id !== id)
      })),
      
      addTransaction: (transaction) => set((state) => ({
        transactions: [transaction, ...state.transactions].slice(0, 100) // 保留最近100条
      })),
      
      clearTransactions: () => set({ transactions: [] })
    }),
    {
      name: 'carbon-app-storage',
      partialize: (state) => ({
        theme: state.theme,
        language: state.language,
        userProfile: state.userProfile
      })
    }
  )
);

export default useAppStore;
```

### 5. 国际化实现

#### i18n配置

```typescript
// i18n/index.ts - 国际化配置
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import LanguageDetector from 'i18next-browser-languagedetector';

// 语言资源
import zhTranslations from './locales/zh.json';
import enTranslations from './locales/en.json';

const resources = {
  zh: {
    translation: zhTranslations
  },
  en: {
    translation: enTranslations
  }
};

i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    resources,
    fallbackLng: 'zh',
    debug: import.meta.env.DEV,
    
    interpolation: {
      escapeValue: false
    },
    
    detection: {
      order: ['localStorage', 'navigator', 'htmlTag'],
      caches: ['localStorage']
    }
  });

export default i18n;
```

```json
// locales/zh.json - 中文语言包
{
  "common": {
    "loading": "加载中...",
    "error": "错误",
    "success": "成功",
    "confirm": "确认",
    "cancel": "取消",
    "save": "保存",
    "delete": "删除",
    "edit": "编辑",
    "view": "查看",
    "connectWallet": "请先连接钱包",
    "credits": "碳信用"
  },
  "navigation": {
    "dashboard": "仪表板",
    "market": "碳信用市场",
    "emissions": "排放记录",
    "projects": "项目管理",
    "profile": "个人资料"
  },
  "market": {
    "title": "碳信用市场",
    "description": "购买和出售碳信用，参与碳中和行动",
    "yourBalance": "您的余额",
    "createListing": "创建挂单",
    "noListings": "暂无挂单",
    "noListingsDescription": "市场上暂时没有可用的碳信用挂单",
    "confirmPurchase": "确认购买",
    "purchaseDetails": "您将购买 {{amount}} 个碳信用，总价 {{price}} ETH，卖家：{{seller}}",
    "purchaseSuccess": "购买成功！交易哈希：{{hash}}",
    "purchaseError": "购买失败",
    "listingSuccess": "挂单创建成功！交易哈希：{{hash}}",
    "listingError": "创建挂单失败",
    "fillAllFields": "请填写所有字段",
    "invalidAmount": "请输入有效的数量和价格",
    "insufficientBalance": "余额不足",
    "loadError": "加载市场数据失败"
  },
  "emissions": {
    "title": "排放记录",
    "description": "记录和管理您的碳排放数据",
    "totalRecords": "总记录数",
    "addRecord": "添加记录",
    "verifierMode": "验证者模式",
    "noRecords": "暂无排放记录",
    "noRecordsDescription": "您还没有任何排放记录，开始记录您的碳足迹吧",
    "confirmVerify": "确认验证",
    "verifyDetails": "您将验证排放记录 ID: {{id}}",
    "verifySuccess": "验证成功！交易哈希：{{hash}}",
    "verifyError": "验证失败",
    "recordSuccess": "记录成功！交易哈希：{{hash}}",
    "recordError": "记录失败",
    "fillAllFields": "请填写所有字段",
    "invalidAmount": "请输入有效的排放量",
    "verifierOnly": "只有验证者可以执行此操作",
    "loadError": "加载排放记录失败"
  },
  "projects": {
    "title": "项目管理",
    "description": "提交和管理碳信用项目",
    "submitProject": "提交项目",
    "reviewProject": "审核项目",
    "noProjects": "暂无项目",
    "noProjectsDescription": "还没有任何碳信用项目，提交您的第一个项目吧",
    "projectStatus": {
      "Pending": "待审核",
      "Approved": "已批准",
      "Rejected": "已拒绝"
    },
    "submitSuccess": "项目提交成功！交易哈希：{{hash}}",
    "submitError": "项目提交失败",
    "reviewSuccess": "项目审核完成！交易哈希：{{hash}}",
    "reviewError": "项目审核失败",
    "loadError": "加载项目列表失败"
  }
}
```

### 6. 性能优化实现

#### 代码分割和懒加载

```typescript
// App.tsx - 路由懒加载
import { lazy, Suspense } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import LoadingSpinner from './components/ui/LoadingSpinner';

// 懒加载页面组件
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Market = lazy(() => import('./pages/Market'));
const Emissions = lazy(() => import('./pages/Emissions'));
const Projects = lazy(() => import('./pages/Projects'));

const App: React.FC = () => {
  return (
    <Router>
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
        <Suspense fallback={<LoadingSpinner />}>
          <Routes>
            <Route path="/" element={<Dashboard />} />
            <Route path="/market" element={<Market />} />
            <Route path="/emissions" element={<Emissions />} />
            <Route path="/projects" element={<Projects />} />
          </Routes>
        </Suspense>
      </div>
    </Router>
  );
};

export default App;
```

#### 数据缓存和优化

```typescript
// hooks/useDataCache.ts - 数据缓存Hook
import { useState, useEffect, useCallback } from 'react';

interface CacheOptions {
  ttl?: number; // 缓存时间（毫秒）
  key: string;  // 缓存键
}

interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

class DataCache {
  private cache = new Map<string, CacheEntry<any>>();

  set<T>(key: string, data: T, ttl: number = 5 * 60 * 1000): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }

  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    const now = Date.now();
    if (now - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }

  clear(): void {
    this.cache.clear();
  }

  delete(key: string): void {
    this.cache.delete(key);
  }
}

const dataCache = new DataCache();

export const useDataCache = <T>(
  fetchFn: () => Promise<T>,
  options: CacheOptions
) => {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async (forceRefresh = false) => {
    try {
      setLoading(true);
      setError(null);

      // 检查缓存
      if (!forceRefresh) {
        const cachedData = dataCache.get<T>(options.key);
        if (cachedData) {
          setData(cachedData);
          setLoading(false);
          return cachedData;
        }
      }

      // 获取新数据
      const newData = await fetchFn();
      
      // 更新缓存
      dataCache.set(options.key, newData, options.ttl);
      setData(newData);
      
      return newData;
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [fetchFn, options.key, options.ttl]);

  const refresh = useCallback(() => fetchData(true), [fetchData]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return {
    data,
    loading,
    error,
    refresh,
    fetchData
  };
};

export default dataCache;
```

#### 虚拟滚动实现

```typescript
// components/ui/VirtualList.tsx - 虚拟滚动组件
import React, { useState, useEffect, useRef, useMemo } from 'react';

interface VirtualListProps<T> {
  items: T[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: T, index: number) => React.ReactNode;
  overscan?: number;
}

const VirtualList = <T,>({
  items,
  itemHeight,
  containerHeight,
  renderItem,
  overscan = 5
}: VirtualListProps<T>) => {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);

  // 计算可见范围
  const visibleRange = useMemo(() => {
    const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);
    const endIndex = Math.min(
      items.length - 1,
      Math.ceil((scrollTop + containerHeight) / itemHeight) + overscan
    );
    return { startIndex, endIndex };
  }, [scrollTop, itemHeight, containerHeight, items.length, overscan]);

  // 可见项目
  const visibleItems = useMemo(() => {
    const { startIndex, endIndex } = visibleRange;
    return items.slice(startIndex, endIndex + 1).map((item, index) => ({
      item,
      index: startIndex + index
    }));
  }, [items, visibleRange]);

  // 滚动处理
  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop);
  };

  return (
    <div
      ref={containerRef}
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={handleScroll}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {visibleItems.map(({ item, index }) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              top: index * itemHeight,
              left: 0,
              right: 0,
              height: itemHeight
            }}
          >
            {renderItem(item, index)}
          </div>
        ))}
      </div>
    </div>
  );
};

export default VirtualList;
```

## 部署和构建配置

### 1. Vite配置优化

```typescript
// vite.config.ts - Vite构建配置
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    react(),
    visualizer({
      filename: 'dist/stats.html',
      open: true,
      gzipSize: true
    })
  ],
  
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  
  build: {
    target: 'es2020',
    outDir: 'dist',
    sourcemap: false,
    minify: 'terser',
    
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          web3: ['ethers'],
          ui: ['lucide-react', 'sonner'],
          i18n: ['react-i18next', 'i18next']
        }
      }
    },
    
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    }
  },
  
  server: {
    port: 3000,
    open: true,
    cors: true
  },
  
  preview: {
    port: 4173,
    open: true
  },
  
  base: process.env.NODE_ENV === 'production' ? '/carbon-app/' : '/'
});
```

### 2. GitHub Pages部署配置

```json
// package.json - 部署脚本
{
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "predeploy": "npm run build",
    "deploy": "gh-pages -d dist",
    "check": "tsc --noEmit && eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
     "lint": "eslint src --ext ts,tsx --fix",
     "type-check": "tsc --noEmit"
   },
   
   "dependencies": {
     "react": "^18.3.1",
     "react-dom": "^18.3.1",
     "react-router-dom": "^6.28.0",
     "ethers": "^6.13.4",
     "zustand": "^5.0.1",
     "react-i18next": "^15.1.1",
     "i18next": "^23.16.4",
     "i18next-browser-languagedetector": "^8.0.2",
     "lucide-react": "^0.460.0",
     "sonner": "^1.7.1"
   },
   
   "devDependencies": {
     "@types/react": "^18.3.12",
     "@types/react-dom": "^18.3.1",
     "@typescript-eslint/eslint-plugin": "^8.15.0",
     "@typescript-eslint/parser": "^8.15.0",
     "@vitejs/plugin-react": "^4.3.3",
     "autoprefixer": "^10.4.20",
     "eslint": "^9.15.0",
     "eslint-plugin-react-hooks": "^5.0.0",
     "eslint-plugin-react-refresh": "^0.4.14",
     "gh-pages": "^6.2.0",
     "postcss": "^8.4.49",
     "rollup-plugin-visualizer": "^5.12.0",
     "tailwindcss": "^3.4.14",
     "terser": "^5.36.0",
     "typescript": "~5.6.2",
     "vite": "^5.4.10"
   }
 }
 ```

### 3. 环境变量配置

```typescript
// .env.example - 环境变量模板
VITE_CONTRACT_ADDRESS=0xABCDEF1234567890ABCDEF1234567890ABCDEF12
VITE_CHAIN_ID=11155111
VITE_RPC_URL=https://sepolia.infura.io/v3/YOUR_PROJECT_ID
VITE_ETHERSCAN_API_KEY=YOUR_ETHERSCAN_API_KEY
VITE_APP_NAME=Carbon Trading DApp
VITE_APP_VERSION=1.0.0

// .env.local - 本地开发环境
VITE_CONTRACT_ADDRESS=0x1234567890123456789012345678901234567890
VITE_CHAIN_ID=31337
VITE_RPC_URL=http://localhost:8545
VITE_DEBUG=true

// .env.production - 生产环境
VITE_CONTRACT_ADDRESS=0xABCDEF1234567890ABCDEF1234567890ABCDEF12
VITE_CHAIN_ID=11155111
VITE_RPC_URL=https://sepolia.infura.io/v3/YOUR_PROJECT_ID
VITE_DEBUG=false
```

## 错误处理和调试

### 1. 全局错误处理

```typescript
// utils/errorHandler.ts - 全局错误处理
export class AppError extends Error {
  public readonly code: string;
  public readonly statusCode: number;
  public readonly isOperational: boolean;

  constructor(
    message: string,
    code: string = 'UNKNOWN_ERROR',
    statusCode: number = 500,
    isOperational: boolean = true
  ) {
    super(message);
    this.code = code;
    this.statusCode = statusCode;
    this.isOperational = isOperational;

    Error.captureStackTrace(this, this.constructor);
  }
}

export class Web3Error extends AppError {
  constructor(message: string, code: string = 'WEB3_ERROR') {
    super(message, code, 400);
  }
}

export class ContractError extends AppError {
  constructor(message: string, code: string = 'CONTRACT_ERROR') {
    super(message, code, 400);
  }
}

export class NetworkError extends AppError {
  constructor(message: string, code: string = 'NETWORK_ERROR') {
    super(message, code, 503);
  }
}

// 错误处理工具函数
export const handleError = (error: any): AppError => {
  // Web3 错误处理
  if (error.code === 'INSUFFICIENT_FUNDS') {
    return new Web3Error('余额不足，请检查ETH余额', 'INSUFFICIENT_FUNDS');
  }
  
  if (error.code === 'USER_REJECTED') {
    return new Web3Error('用户取消了交易', 'USER_REJECTED');
  }
  
  if (error.code === 'NETWORK_ERROR') {
    return new NetworkError('网络连接失败，请检查网络设置', 'NETWORK_ERROR');
  }
  
  // 合约执行错误
  if (error.message?.includes('execution reverted')) {
    const reason = extractRevertReason(error.message);
    return new ContractError(`智能合约执行失败: ${reason}`, 'EXECUTION_REVERTED');
  }
  
  // 未知错误
  if (error instanceof AppError) {
    return error;
  }
  
  return new AppError(
    error.message || '发生未知错误',
    'UNKNOWN_ERROR',
    500,
    false
  );
};

// 提取合约回滚原因
const extractRevertReason = (errorMessage: string): string => {
  const match = errorMessage.match(/reason="([^"]+)"/);
  return match ? match[1] : '未知原因';
};

// 错误边界组件
import React from 'react';

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends React.Component<
  React.PropsWithChildren<{}>,
  ErrorBoundaryState
> {
  constructor(props: React.PropsWithChildren<{}>) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('错误边界捕获到错误:', error, errorInfo);
    
    // 发送错误报告到监控服务
    if (import.meta.env.PROD) {
      this.reportError(error, errorInfo);
    }
  }

  private reportError = (error: Error, errorInfo: React.ErrorInfo) => {
    // 这里可以集成错误监控服务，如 Sentry
    console.log('报告错误到监控服务:', { error, errorInfo });
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50">
          <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-6">
            <div className="flex items-center mb-4">
              <div className="flex-shrink-0">
                <svg className="h-8 w-8 text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 18.5c-.77.833.192 2.5 1.732 2.5z" />
                </svg>
              </div>
              <div className="ml-3">
                <h3 className="text-lg font-medium text-gray-900">
                  应用程序错误
                </h3>
              </div>
            </div>
            <div className="mb-4">
              <p className="text-sm text-gray-500">
                很抱歉，应用程序遇到了一个错误。请刷新页面重试。
              </p>
              {import.meta.env.DEV && this.state.error && (
                <details className="mt-2">
                  <summary className="text-xs text-gray-400 cursor-pointer">
                    错误详情（开发模式）
                  </summary>
                  <pre className="mt-2 text-xs text-red-600 whitespace-pre-wrap">
                    {this.state.error.stack}
                  </pre>
                </details>
              )}
            </div>
            <div className="flex space-x-3">
              <button
                onClick={() => window.location.reload()}
                className="flex-1 bg-blue-600 text-white px-4 py-2 rounded-md text-sm font-medium hover:bg-blue-700 transition-colors"
              >
                刷新页面
              </button>
              <button
                onClick={() => this.setState({ hasError: false })}
                className="flex-1 bg-gray-300 text-gray-700 px-4 py-2 rounded-md text-sm font-medium hover:bg-gray-400 transition-colors"
              >
                重试
              </button>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### 2. 调试工具实现

```typescript
// utils/debug.ts - 调试工具
export class DebugLogger {
  private static instance: DebugLogger;
  private isEnabled: boolean;
  private logs: Array<{
    timestamp: number;
    level: 'info' | 'warn' | 'error' | 'debug';
    message: string;
    data?: any;
  }> = [];

  private constructor() {
    this.isEnabled = import.meta.env.DEV || import.meta.env.VITE_DEBUG === 'true';
  }

  static getInstance(): DebugLogger {
    if (!DebugLogger.instance) {
      DebugLogger.instance = new DebugLogger();
    }
    return DebugLogger.instance;
  }

  private log(level: 'info' | 'warn' | 'error' | 'debug', message: string, data?: any) {
    if (!this.isEnabled) return;

    const logEntry = {
      timestamp: Date.now(),
      level,
      message,
      data
    };

    this.logs.push(logEntry);
    
    // 保持最近1000条日志
    if (this.logs.length > 1000) {
      this.logs = this.logs.slice(-1000);
    }

    // 输出到控制台
    const timestamp = new Date(logEntry.timestamp).toISOString();
    const prefix = `[${timestamp}] [${level.toUpperCase()}]`;
    
    switch (level) {
      case 'error':
        console.error(prefix, message, data);
        break;
      case 'warn':
        console.warn(prefix, message, data);
        break;
      case 'debug':
        console.debug(prefix, message, data);
        break;
      default:
        console.log(prefix, message, data);
    }
  }

  info(message: string, data?: any) {
    this.log('info', message, data);
  }

  warn(message: string, data?: any) {
    this.log('warn', message, data);
  }

  error(message: string, data?: any) {
    this.log('error', message, data);
  }

  debug(message: string, data?: any) {
    this.log('debug', message, data);
  }

  // 获取所有日志
  getLogs() {
    return [...this.logs];
  }

  // 清空日志
  clearLogs() {
    this.logs = [];
  }

  // 导出日志
  exportLogs() {
    const logsJson = JSON.stringify(this.logs, null, 2);
    const blob = new Blob([logsJson], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `carbon-app-logs-${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    URL.revokeObjectURL(url);
  }
}

// 全局调试器实例
export const logger = DebugLogger.getInstance();

// Web3调试工具
export class Web3Debugger {
  static logTransaction(tx: any, description: string = '') {
    logger.debug(`Web3 Transaction ${description}`, {
      hash: tx.hash,
      from: tx.from,
      to: tx.to,
      value: tx.value?.toString(),
      gasLimit: tx.gasLimit?.toString(),
      gasPrice: tx.gasPrice?.toString(),
      nonce: tx.nonce
    });
  }

  static logContractCall(contractAddress: string, method: string, params: any[], result?: any) {
    logger.debug(`Contract Call: ${method}`, {
      contract: contractAddress,
      method,
      params,
      result
    });
  }

  static logEvent(event: any, description: string = '') {
    logger.debug(`Contract Event ${description}`, {
      event: event.event,
      args: event.args,
      transactionHash: event.transactionHash,
      blockNumber: event.blockNumber
    });
  }

  static logError(error: any, context: string = '') {
    logger.error(`Web3 Error ${context}`, {
      code: error.code,
      message: error.message,
      data: error.data,
      stack: error.stack
    });
  }
}
```

## 测试策略

### 1. 单元测试

```typescript
// tests/utils/contractService.test.ts - 合约服务测试
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { ethers } from 'ethers';
import ContractService from '../../src/services/contractService';

// Mock ethers
vi.mock('ethers');

describe('ContractService', () => {
  let contractService: ContractService;
  let mockContract: any;
  let mockSigner: any;

  beforeEach(() => {
    mockContract = {
      recordEmission: vi.fn(),
      getUserEmissions: vi.fn(),
      verifyEmission: vi.fn(),
      createProject: vi.fn(),
      getAllProjects: vi.fn(),
      listCredit: vi.fn(),
      buyCredit: vi.fn(),
      getAllListings: vi.fn(),
      carbonCredits: vi.fn()
    };

    mockSigner = {
      getAddress: vi.fn().mockResolvedValue('0x1234567890123456789012345678901234567890')
    };

    contractService = new ContractService(mockContract, mockSigner);
  });

  describe('recordEmission', () => {
    it('should record emission successfully', async () => {
      const mockTx = {
        hash: '0xabcdef',
        wait: vi.fn().mockResolvedValue({
          hash: '0xabcdef',
          blockNumber: 12345,
          gasUsed: ethers.getBigInt('21000')
        })
      };

      mockContract.recordEmission.mockResolvedValue(mockTx);

      const result = await contractService.recordEmission(10.5, 'transportation');

      expect(mockContract.recordEmission).toHaveBeenCalledWith(
        ethers.parseUnits('10.5', 18),
        'transportation'
      );
      expect(result.type).toBe('emission');
      expect(result.amount).toBe(10.5);
      expect(result.status).toBe('confirmed');
    });

    it('should handle insufficient funds error', async () => {
      const error = new Error('insufficient funds');
      error.code = 'INSUFFICIENT_FUNDS';
      mockContract.recordEmission.mockRejectedValue(error);

      await expect(
        contractService.recordEmission(10.5, 'transportation')
      ).rejects.toThrow('余额不足，请检查ETH余额');
    });
  });

  describe('getUserEmissions', () => {
    it('should get user emissions successfully', async () => {
      const mockEmissions = [
        {
          amount: ethers.parseUnits('10.5', 18),
          activityType: 'transportation',
          timestamp: ethers.getBigInt('1640995200'),
          verified: false,
          verifier: ethers.ZeroAddress
        }
      ];

      mockContract.getUserEmissions.mockResolvedValue(mockEmissions);

      const result = await contractService.getUserEmissions('0x1234567890123456789012345678901234567890');

      expect(result).toHaveLength(1);
      expect(result[0].amount).toBe(10.5);
      expect(result[0].activityType).toBe('transportation');
      expect(result[0].verified).toBe(false);
    });
  });
});
```

### 2. 集成测试

```typescript
// tests/integration/web3Integration.test.ts - Web3集成测试
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { ethers } from 'ethers';
import { Web3Provider } from '../../src/contexts/Web3Context';
import ContractService from '../../src/services/contractService';

describe('Web3 Integration Tests', () => {
  let provider: ethers.JsonRpcProvider;
  let signer: ethers.Wallet;
  let contract: ethers.Contract;
  let contractService: ContractService;

  beforeAll(async () => {
    // 连接到本地测试网络
    provider = new ethers.JsonRpcProvider('http://localhost:8545');
    
    // 使用测试私钥创建钱包
    signer = new ethers.Wallet(
      '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
      provider
    );

    // 部署测试合约
    const contractFactory = new ethers.ContractFactory(
      CarbonCreditSystemABI,
      CarbonCreditSystemBytecode,
      signer
    );
    
    contract = await contractFactory.deploy();
    await contract.waitForDeployment();

    contractService = new ContractService(contract, signer);
  });

  afterAll(async () => {
    // 清理测试环境
  });

  it('should record and retrieve emissions', async () => {
    // 记录排放
    const transaction = await contractService.recordEmission(10.5, 'transportation');
    expect(transaction.status).toBe('confirmed');

    // 获取排放记录
    const emissions = await contractService.getUserEmissions(await signer.getAddress());
    expect(emissions).toHaveLength(1);
    expect(emissions[0].amount).toBe(10.5);
    expect(emissions[0].activityType).toBe('transportation');
  });

  it('should create and list projects', async () => {
    // 创建项目
    const projectTx = await contractService.submitProject(
      'Solar Farm Project',
      'A large-scale solar energy project',
      'renewable_energy',
      1000
    );
    expect(projectTx.status).toBe('confirmed');

    // 获取项目列表
    const projects = await contractService.getAllProjects();
    expect(projects).toHaveLength(1);
    expect(projects[0].name).toBe('Solar Farm Project');
    expect(projects[0].totalCredits).toBe(1000);
  });

  it('should handle market operations', async () => {
    // 首先需要有碳信用余额
    // 这里假设合约已经给用户分配了一些碳信用
    
    // 上架碳信用
    const listingTx = await contractService.listCredit(100, 0.01, 1);
    expect(listingTx.status).toBe('confirmed');

    // 获取市场挂单
    const listings = await contractService.getAllListings();
    expect(listings).toHaveLength(1);
    expect(listings[0].amount).toBe(100);
    expect(listings[0].pricePerCredit).toBe(0.01);
  });
});
```

### 3. E2E测试

```typescript
// tests/e2e/userFlow.test.ts - 端到端测试
import { test, expect } from '@playwright/test';

test.describe('Carbon Trading DApp E2E Tests', () => {
  test.beforeEach(async ({ page }) => {
    // 访问应用
    await page.goto('http://localhost:3000');
    
    // 等待页面加载
    await page.waitForLoadState('networkidle');
  });

  test('should connect wallet and display user info', async ({ page }) => {
    // 点击连接钱包按钮
    await page.click('[data-testid="connect-wallet-button"]');
    
    // 模拟MetaMask连接（需要配置测试环境）
    // 这里假设已经配置了测试钱包
    
    // 验证钱包连接成功
    await expect(page.locator('[data-testid="wallet-address"]')).toBeVisible();
    await expect(page.locator('[data-testid="user-balance"]')).toBeVisible();
  });

  test('should record emission successfully', async ({ page }) => {
    // 假设钱包已连接
    await page.goto('/emissions');
    
    // 点击添加排放记录按钮
    await page.click('[data-testid="add-emission-button"]');
    
    // 填写表单
    await page.fill('[data-testid="emission-amount"]', '10.5');
    await page.selectOption('[data-testid="activity-type"]', 'transportation');
    
    // 提交表单
    await page.click('[data-testid="submit-emission"]');
    
    // 验证成功消息
    await expect(page.locator('[data-testid="success-message"]')).toBeVisible();
    
    // 验证排放记录出现在列表中
    await expect(page.locator('[data-testid="emission-record"]')).toBeVisible();
  });

  test('should navigate between pages correctly', async ({ page }) => {
    // 测试导航
    await page.click('[data-testid="nav-market"]');
    await expect(page).toHaveURL(/.*\/market/);
    
    await page.click('[data-testid="nav-projects"]');
    await expect(page).toHaveURL(/.*\/projects/);
    
    await page.click('[data-testid="nav-emissions"]');
    await expect(page).toHaveURL(/.*\/emissions/);
  });

  test('should handle errors gracefully', async ({ page }) => {
    // 模拟网络错误
    await page.route('**/api/**', route => route.abort());
    
    // 尝试执行操作
    await page.goto('/market');
    
    // 验证错误处理
    await expect(page.locator('[data-testid="error-message"]')).toBeVisible();
  });
});
```

## 性能监控和优化

### 1. 性能监控

```typescript
// utils/performance.ts - 性能监控
export class PerformanceMonitor {
  private static instance: PerformanceMonitor;
  private metrics: Map<string, number[]> = new Map();

  static getInstance(): PerformanceMonitor {
    if (!PerformanceMonitor.instance) {
      PerformanceMonitor.instance = new PerformanceMonitor();
    }
    return PerformanceMonitor.instance;
  }

  // 测量函数执行时间
  async measureAsync<T>(name: string, fn: () => Promise<T>): Promise<T> {
    const start = performance.now();
    try {
      const result = await fn();
      const duration = performance.now() - start;
      this.recordMetric(name, duration);
      return result;
    } catch (error) {
      const duration = performance.now() - start;
      this.recordMetric(`${name}_error`, duration);
      throw error;
    }
  }

  // 测量同步函数执行时间
  measure<T>(name: string, fn: () => T): T {
    const start = performance.now();
    try {
      const result = fn();
      const duration = performance.now() - start;
      this.recordMetric(name, duration);
      return result;
    } catch (error) {
      const duration = performance.now() - start;
      this.recordMetric(`${name}_error`, duration);
      throw error;
    }
  }

  // 记录指标
  private recordMetric(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    
    const values = this.metrics.get(name)!;
    values.push(value);
    
    // 保持最近100个值
    if (values.length > 100) {
      values.shift();
    }
  }

  // 获取指标统计
  getMetrics(name: string) {
    const values = this.metrics.get(name) || [];
    if (values.length === 0) {
      return null;
    }

    const sorted = [...values].sort((a, b) => a - b);
    return {
      count: values.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      avg: values.reduce((sum, val) => sum + val, 0) / values.length,
      median: sorted[Math.floor(sorted.length / 2)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)]
    };
  }

  // 获取所有指标
  getAllMetrics() {
    const result: Record<string, any> = {};
    for (const [name] of this.metrics) {
      result[name] = this.getMetrics(name);
    }
    return result;
  }

  // 清空指标
  clearMetrics() {
    this.metrics.clear();
  }
}

export const performanceMonitor = PerformanceMonitor.getInstance();

// React性能监控Hook
export const usePerformanceMonitor = (componentName: string) => {
  const renderStart = useRef<number>(0);
  
  useEffect(() => {
    renderStart.current = performance.now();
  });
  
  useEffect(() => {
    const renderTime = performance.now() - renderStart.current;
    performanceMonitor.recordMetric(`component_render_${componentName}`, renderTime);
  });
};
```

### 2. 内存管理

```typescript
// utils/memoryManager.ts - 内存管理
export class MemoryManager {
  private static instance: MemoryManager;
  private cleanupTasks: Set<() => void> = new Set();
  private intervalId: number | null = null;

  static getInstance(): MemoryManager {
    if (!MemoryManager.instance) {
      MemoryManager.instance = new MemoryManager();
    }
    return MemoryManager.instance;
  }

  // 注册清理任务
  registerCleanup(cleanup: () => void) {
    this.cleanupTasks.add(cleanup);
    return () => this.cleanupTasks.delete(cleanup);
  }

  // 执行所有清理任务
  cleanup() {
    this.cleanupTasks.forEach(task => {
      try {
        task();
      } catch (error) {
        console.error('清理任务执行失败:', error);
      }
    });
  }

  // 开始内存监控
  startMonitoring(interval: number = 30000) {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }

    this.intervalId = window.setInterval(() => {
      this.checkMemoryUsage();
    }, interval);
  }

  // 停止内存监控
  stopMonitoring() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }

  // 检查内存使用情况
  private checkMemoryUsage() {
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      const usedMB = memory.usedJSHeapSize / 1024 / 1024;
      const totalMB = memory.totalJSHeapSize / 1024 / 1024;
      const limitMB = memory.jsHeapSizeLimit / 1024 / 1024;
      
      console.log(`内存使用情况: ${usedMB.toFixed(2)}MB / ${totalMB.toFixed(2)}MB (限制: ${limitMB.toFixed(2)}MB)`);
      
      // 如果内存使用超过80%，触发清理
      if (usedMB / limitMB > 0.8) {
        console.warn('内存使用率过高，执行清理操作');
        this.cleanup();
        
        // 建议垃圾回收（仅在开发环境）
        if (import.meta.env.DEV && 'gc' in window) {
          (window as any).gc();
        }
      }
    }
  }

  // 获取内存信息
  getMemoryInfo() {
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      return {
        used: memory.usedJSHeapSize,
        total: memory.totalJSHeapSize,
        limit: memory.jsHeapSizeLimit,
        usedMB: memory.usedJSHeapSize / 1024 / 1024,
        totalMB: memory.totalJSHeapSize / 1024 / 1024,
        limitMB: memory.jsHeapSizeLimit / 1024 / 1024
      };
    }
    return null;
  }
}

export const memoryManager = MemoryManager.getInstance();
```

## 总结

本文档详细分析了碳交易DApp的代码实现，涵盖了以下核心方面：

### 技术架构优势

1. **现代化技术栈**: 采用React 18 + TypeScript + Vite的现代前端技术栈
2. **模块化设计**: 清晰的项目结构和组件分离
3. **类型安全**: 全面的TypeScript类型定义
4. **性能优化**: 代码分割、懒加载、虚拟滚动等优化策略
5. **国际化支持**: 完整的多语言支持系统

### Web3集成特色

1. **完整的钱包集成**: MetaMask连接、网络切换、账户管理
2. **智能合约服务层**: 封装良好的合约交互接口
3. **事件监听机制**: 实时监听区块链事件
4. **错误处理**: 完善的Web3错误处理和用户友好提示
5. **交易状态跟踪**: 详细的交易状态管理

### 用户体验设计

1. **响应式设计**: 适配各种设备屏幕
2. **加载状态**: 完善的加载和错误状态处理
3. **交互反馈**: 实时的操作反馈和通知系统
4. **数据可视化**: 清晰的数据展示和统计图表
5. **无障碍访问**: 考虑了可访问性的设计

### 开发体验

1. **开发工具**: 完整的开发、构建、部署工具链
2. **代码质量**: ESLint、TypeScript检查
3. **调试支持**: 详细的日志和调试工具
4. **测试覆盖**: 单元测试、集成测试、E2E测试
5. **性能监控**: 实时性能监控和优化建议

### 部署和运维

1. **自动化部署**: GitHub Actions + GitHub Pages
2. **环境管理**: 多环境配置支持
3. **错误监控**: 全局错误捕获和报告
4. **性能监控**: 内存管理和性能指标收集
5. **版本管理**: 语义化版本控制

### 安全性考虑

1. **输入验证**: 严格的用户输入验证
2. **权限控制**: 基于角色的访问控制
3. **错误处理**: 安全的错误信息展示
4. **数据保护**: 敏感数据的安全处理
5. **网络安全**: HTTPS和安全的API调用

这个碳交易DApp项目展现了现代Web3应用开发的最佳实践，结合了前端技术的先进性和区块链技术的创新性，为用户提供了一个功能完整、体验优秀的去中心化碳信用交易平台。通过详细的代码分析，我们可以看到项目在技术架构、用户体验、开发效率和系统可靠性方面都达到了较高的水准。