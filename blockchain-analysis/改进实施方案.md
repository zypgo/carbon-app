# 区块链功能改进实施方案

## 1. 立即可行的改进方案（1-2周内完成）

### 1.1 启用智能合约调用

#### 步骤1：修改排放记录页面

```typescript
// src/pages/Emissions.tsx - 修改建议

// ❌ 当前的模拟实现
const handleSubmit = async (e: React.FormEvent) => {
  // ... 省略验证代码
  
  try {
    setIsSubmitting(true)
    
    // 注释掉的智能合约调用
    // await contract.recordEmission(parseFloat(amount), activity)
    
    // 模拟延迟
    setTimeout(() => {
      // 本地状态更新
    }, 2000)
  }
}

// ✅ 修改后的区块链实现
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault()
  
  if (!activity || !amount) {
    toast({
      title: '请填写完整信息',
      status: 'warning',
      duration: 3000,
      isClosable: true,
    })
    return
  }

  // 检查合约和钱包连接
  if (!contract || !account) {
    toast({
      title: '请先连接钱包',
      status: 'warning',
      duration: 3000,
      isClosable: true,
    })
    return
  }

  try {
    setIsSubmitting(true)
    
    // ✅ 调用真实的智能合约方法
    const tx = await contract.recordEmission(
      ethers.parseEther(amount),  // 转换为Wei单位
      activity                    // 活动类型
    )
    
    // 显示交易已发送的提示
    toast({
      title: '交易已发送',
      description: `交易哈希: ${tx.hash.substring(0, 10)}...`,
      status: 'info',
      duration: 3000,
      isClosable: true,
    })
    
    // 等待交易确认
    const receipt = await tx.wait()
    
    // 交易成功后的处理
    if (receipt.status === 1) {
      // 从区块链重新获取数据
      await refreshEmissionsFromBlockchain()
      
      // 重置表单
      setActivity('')
      setAmount('')
      
      toast({
        title: '排放记录已上链',
        description: `区块号: ${receipt.blockNumber}`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
    } else {
      throw new Error('交易失败')
    }
    
  } catch (error: any) {
    console.error('记录失败:', error)
    
    // 详细的错误处理
    let errorMessage = '请稍后重试'
    if (error.code === 'INSUFFICIENT_FUNDS') {
      errorMessage = 'ETH余额不足，无法支付Gas费用'
    } else if (error.code === 'USER_REJECTED') {
      errorMessage = '用户取消了交易'
    } else if (error.message?.includes('execution reverted')) {
      errorMessage = '智能合约执行失败，请检查参数'
    }
    
    toast({
      title: '记录失败',
      description: errorMessage,
      status: 'error',
      duration: 3000,
      isClosable: true,
    })
  } finally {
    setIsSubmitting(false)
  }
}

// ✅ 新增：从区块链刷新排放数据
const refreshEmissionsFromBlockchain = async () => {
  try {
    if (contract) {
      const blockchainEmissions = await contract.getUserEmissions()
      
      const formattedEmissions = blockchainEmissions.map((emission: any, index: number) => ({
        id: index + 1,
        activity: emission.activity,
        amount: parseFloat(ethers.formatEther(emission.amount)),
        timestamp: Number(emission.timestamp) * 1000  // 转换为毫秒
      }))
      
      setEmissions(formattedEmissions)
    }
  } catch (error) {
    console.error('刷新排放数据失败:', error)
  }
}

// ✅ 新增：页面加载时从区块链获取数据
useEffect(() => {
  if (contract && account) {
    refreshEmissionsFromBlockchain()
  }
}, [contract, account])
```

#### 步骤2：修改市场交易页面

```typescript
// src/pages/Market.tsx - 修改建议

// ✅ 修改购买功能
const handleBuy = async (listingId: number, price: number, amount: number, seller: string) => {
  if (!signer || !contract) {
    toast({
      title: '请先连接钱包',
      status: 'warning',
      duration: 3000,
      isClosable: true,
    })
    return
  }

  try {
    setBuyingId(listingId)
    
    // ✅ 调用智能合约的buyCredit方法
    const totalPrice = price * amount
    const tx = await contract.buyCredit(listingId, {
      value: ethers.parseEther(totalPrice.toString())
    })
    
    toast({
      title: '交易已发送',
      description: `交易哈希: ${tx.hash.substring(0, 10)}...`,
      status: 'info',
      duration: 3000,
      isClosable: true,
    })
    
    const receipt = await tx.wait()
    
    if (receipt.status === 1) {
      // 从区块链重新获取市场数据
      await refreshMarketDataFromBlockchain()
      
      // 更新用户余额
      await updateUserBalance()
      
      toast({
        title: '购买成功',
        description: `已购买 ${amount} 个碳信用`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
    }
    
  } catch (error: any) {
    console.error('购买失败:', error)
    
    let errorMessage = '请稍后重试'
    if (error.code === 'INSUFFICIENT_FUNDS') {
      errorMessage = 'ETH余额不足'
    } else if (error.code === 'USER_REJECTED') {
      errorMessage = '用户取消了交易'
    } else if (error.message?.includes('listing not active')) {
      errorMessage = '该碳信用已被购买'
    }
    
    toast({
      title: '购买失败',
      description: errorMessage,
      status: 'error',
      duration: 3000,
      isClosable: true,
    })
  } finally {
    setBuyingId(null)
  }
}

// ✅ 修改销售功能
const handleSell = async () => {
  if (!contract || !account) {
    toast({
      title: '请先连接钱包',
      status: 'warning',
      duration: 3000,
      isClosable: true,
    })
    return
  }

  try {
    setIsSelling(true)
    
    // ✅ 调用智能合约的listCredit方法
    const tx = await contract.listCredit(
      ethers.parseEther(amount.toString()),
      ethers.parseEther(price.toString())
    )
    
    toast({
      title: '上架交易已发送',
      description: `交易哈希: ${tx.hash.substring(0, 10)}...`,
      status: 'info',
      duration: 3000,
      isClosable: true,
    })
    
    const receipt = await tx.wait()
    
    if (receipt.status === 1) {
      // 从区块链重新获取市场数据
      await refreshMarketDataFromBlockchain()
      
      // 重置表单
      setAmount('')
      setPrice('')
      
      toast({
        title: '上架成功',
        description: `已上架 ${amount} 个碳信用`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
    }
    
  } catch (error: any) {
    console.error('上架失败:', error)
    
    let errorMessage = '请稍后重试'
    if (error.code === 'INSUFFICIENT_FUNDS') {
      errorMessage = 'ETH余额不足，无法支付Gas费用'
    } else if (error.code === 'USER_REJECTED') {
      errorMessage = '用户取消了交易'
    } else if (error.message?.includes('insufficient balance')) {
      errorMessage = '碳信用余额不足'
    }
    
    toast({
      title: '上架失败',
      description: errorMessage,
      status: 'error',
      duration: 3000,
      isClosable: true,
    })
  } finally {
    setIsSelling(false)
  }
}

// ✅ 新增：从区块链刷新市场数据
const refreshMarketDataFromBlockchain = async () => {
  try {
    if (contract) {
      const blockchainListings = await contract.getAllListings()
      
      const formattedListings = blockchainListings
        .map((listing: any, index: number) => ({
          id: index,
          seller: listing.seller,
          amount: parseFloat(ethers.formatEther(listing.amount)),
          price: parseFloat(ethers.formatEther(listing.price)),
          active: listing.active
        }))
        .filter((listing: any) => listing.active)  // 只显示活跃的上架
      
      setListings(formattedListings)
    }
  } catch (error) {
    console.error('刷新市场数据失败:', error)
  }
}

// ✅ 新增：更新用户余额
const updateUserBalance = async () => {
  try {
    if (contract && account) {
      const balance = await contract.balanceOf(account)
      const formattedBalance = parseFloat(ethers.formatEther(balance))
      
      // 更新本地用户数据
      const userData = getUserData(account)
      userData.carbonCredits = formattedBalance
      saveUserData(account, userData)
    }
  } catch (error) {
    console.error('更新余额失败:', error)
  }
}

// ✅ 页面加载时从区块链获取数据
useEffect(() => {
  if (contract) {
    refreshMarketDataFromBlockchain()
  }
}, [contract])

useEffect(() => {
  if (contract && account) {
    updateUserBalance()
  }
}, [contract, account])
```

### 1.2 配置智能合约地址

#### 步骤1：创建环境配置文件

```bash
# .env.local - 创建环境变量文件

# 智能合约地址（需要部署后获得）
VITE_CONTRACT_ADDRESS=0x1234567890123456789012345678901234567890

# 网络配置
VITE_CHAIN_ID=11155111  # Sepolia测试网
VITE_NETWORK_NAME=Sepolia
VITE_RPC_URL=https://sepolia.infura.io/v3/YOUR_PROJECT_ID
```

#### 步骤2：修改Web3Context配置检查

```typescript
// src/contexts/Web3Context.tsx - 添加配置检查

const connectWallet = async () => {
  if (!window.ethereum) {
    alert('请安装 MetaMask!')
    return
  }

  try {
    setIsConnecting(true)
    
    const browserProvider = new ethers.BrowserProvider(window.ethereum)
    const accounts = await browserProvider.send('eth_requestAccounts', [])
    
    if (accounts.length > 0) {
      const userAccount = accounts[0]
      const userSigner = await browserProvider.getSigner()
      const network = await browserProvider.getNetwork()
      const chainIdentifier = Number(network.chainId)
      
      // ✅ 检查网络是否正确
      const expectedChainId = parseInt(import.meta.env.VITE_CHAIN_ID || '1')
      if (chainIdentifier !== expectedChainId) {
        toast({
          title: '网络错误',
          description: `请切换到 ${import.meta.env.VITE_NETWORK_NAME || 'Ethereum'} 网络`,
          status: 'warning',
          duration: 5000,
          isClosable: true,
        })
        return
      }
      
      setAccount(userAccount)
      setChainId(chainIdentifier)
      setProvider(browserProvider)
      setSigner(userSigner)
      
      // ✅ 检查合约地址配置
      const contractAddress = import.meta.env.VITE_CONTRACT_ADDRESS
      if (!contractAddress || contractAddress === '0x1234567890123456789012345678901234567890') {
        console.warn('⚠️ 智能合约地址未正确配置，请在.env.local中设置VITE_CONTRACT_ADDRESS')
        toast({
          title: '配置警告',
          description: '智能合约地址未配置，部分功能可能无法使用',
          status: 'warning',
          duration: 5000,
          isClosable: true,
        })
      } else {
        // 创建合约实例
        const carbonContract = new ethers.Contract(
          contractAddress,
          CarbonCreditSystemABI,
          userSigner
        )
        setContract(carbonContract)
        
        console.log('✅ 智能合约已连接:', contractAddress)
      }
    }
  } catch (error) {
    console.error('连接钱包失败:', error)
  } finally {
    setIsConnecting(false)
  }
}
```

### 1.3 添加基础错误处理

#### 创建错误处理工具

```typescript
// src/utils/errorHandler.ts - 新建文件

export interface BlockchainError {
  code: string
  message: string
  userMessage: string
}

export const parseBlockchainError = (error: any): BlockchainError => {
  // 用户拒绝交易
  if (error.code === 'ACTION_REJECTED' || error.code === 4001) {
    return {
      code: 'USER_REJECTED',
      message: error.message,
      userMessage: '用户取消了交易'
    }
  }
  
  // 余额不足
  if (error.code === 'INSUFFICIENT_FUNDS' || error.message?.includes('insufficient funds')) {
    return {
      code: 'INSUFFICIENT_FUNDS',
      message: error.message,
      userMessage: 'ETH余额不足，无法支付Gas费用'
    }
  }
  
  // 合约执行失败
  if (error.message?.includes('execution reverted')) {
    let userMessage = '智能合约执行失败'
    
    // 解析具体的revert原因
    if (error.message.includes('insufficient balance')) {
      userMessage = '碳信用余额不足'
    } else if (error.message.includes('listing not active')) {
      userMessage = '该碳信用已被购买'
    } else if (error.message.includes('invalid amount')) {
      userMessage = '输入金额无效'
    }
    
    return {
      code: 'CONTRACT_REVERT',
      message: error.message,
      userMessage
    }
  }
  
  // 网络错误
  if (error.code === 'NETWORK_ERROR') {
    return {
      code: 'NETWORK_ERROR',
      message: error.message,
      userMessage: '网络连接失败，请检查网络设置'
    }
  }
  
  // 默认错误
  return {
    code: 'UNKNOWN_ERROR',
    message: error.message || '未知错误',
    userMessage: '操作失败，请稍后重试'
  }
}

// 通用的交易执行函数
export const executeTransaction = async (
  transactionFunction: () => Promise<any>,
  description: string,
  onSuccess?: (receipt: any) => void,
  onError?: (error: BlockchainError) => void
) => {
  try {
    console.log(`🚀 开始执行: ${description}`)
    
    // 执行交易
    const tx = await transactionFunction()
    console.log(`📤 交易已发送: ${tx.hash}`)
    
    // 等待确认
    const receipt = await tx.wait()
    
    if (receipt.status === 1) {
      console.log(`✅ 交易成功: ${description}`, {
        hash: receipt.hash,
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed.toString()
      })
      
      onSuccess?.(receipt)
      return receipt
    } else {
      throw new Error('交易失败')
    }
    
  } catch (error) {
    const parsedError = parseBlockchainError(error)
    console.error(`❌ 交易失败: ${description}`, parsedError)
    
    onError?.(parsedError)
    throw parsedError
  }
}
```

## 2. 中期改进方案（1-2个月内完成）

### 2.1 实现事件监听机制

#### 创建事件监听服务

```typescript
// src/services/eventListenerService.ts - 新建文件

import { ethers } from 'ethers'
import { toast } from '@chakra-ui/react'

export class EventListenerService {
  private contract: ethers.Contract
  private account: string
  private listeners: { [key: string]: (...args: any[]) => void } = {}

  constructor(contract: ethers.Contract, account: string) {
    this.contract = contract
    this.account = account
  }

  // 启动所有事件监听
  startListening() {
    this.listenToEmissionEvents()
    this.listenToTradingEvents()
    this.listenToListingEvents()
  }

  // 监听排放记录事件
  private listenToEmissionEvents() {
    const emissionFilter = this.contract.filters.EmissionRecorded(this.account)
    
    this.listeners.emission = (user: string, amount: bigint, activity: string, event: any) => {
      console.log('🌱 新的排放记录:', {
        user,
        amount: ethers.formatEther(amount),
        activity,
        transactionHash: event.transactionHash
      })
      
      toast({
        title: '排放记录已确认',
        description: `${activity}: ${ethers.formatEther(amount)} 吨`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
      
      // 触发数据刷新
      this.onEmissionRecorded?.({
        amount: parseFloat(ethers.formatEther(amount)),
        activity,
        timestamp: Date.now(),
        transactionHash: event.transactionHash
      })
    }
    
    this.contract.on(emissionFilter, this.listeners.emission)
  }

  // 监听交易事件
  private listenToTradingEvents() {
    // 监听购买事件（作为买家）
    const buyFilter = this.contract.filters.CreditPurchased(this.account, null, null, null)
    
    this.listeners.buy = (buyer: string, seller: string, amount: bigint, price: bigint, event: any) => {
      console.log('💰 购买成功:', {
        buyer,
        seller,
        amount: ethers.formatEther(amount),
        price: ethers.formatEther(price),
        transactionHash: event.transactionHash
      })
      
      toast({
        title: '购买成功',
        description: `已购买 ${ethers.formatEther(amount)} 个碳信用`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
      
      this.onCreditPurchased?.({
        type: 'buy',
        amount: parseFloat(ethers.formatEther(amount)),
        price: parseFloat(ethers.formatEther(price)),
        counterparty: seller,
        transactionHash: event.transactionHash
      })
    }
    
    // 监听销售事件（作为卖家）
    const sellFilter = this.contract.filters.CreditPurchased(null, this.account, null, null)
    
    this.listeners.sell = (buyer: string, seller: string, amount: bigint, price: bigint, event: any) => {
      console.log('💸 销售成功:', {
        buyer,
        seller,
        amount: ethers.formatEther(amount),
        price: ethers.formatEther(price),
        transactionHash: event.transactionHash
      })
      
      toast({
        title: '销售成功',
        description: `已售出 ${ethers.formatEther(amount)} 个碳信用`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
      
      this.onCreditSold?.({
        type: 'sell',
        amount: parseFloat(ethers.formatEther(amount)),
        price: parseFloat(ethers.formatEther(price)),
        counterparty: buyer,
        transactionHash: event.transactionHash
      })
    }
    
    this.contract.on(buyFilter, this.listeners.buy)
    this.contract.on(sellFilter, this.listeners.sell)
  }

  // 监听上架事件
  private listenToListingEvents() {
    const listingFilter = this.contract.filters.CreditListed(null, null, null)
    
    this.listeners.listing = (seller: string, amount: bigint, price: bigint, event: any) => {
      console.log('📋 新的上架:', {
        seller,
        amount: ethers.formatEther(amount),
        price: ethers.formatEther(price),
        transactionHash: event.transactionHash
      })
      
      // 如果不是自己的上架，显示通知
      if (seller.toLowerCase() !== this.account.toLowerCase()) {
        toast({
          title: '新的碳信用上架',
          description: `${ethers.formatEther(amount)} 个碳信用，单价 ${ethers.formatEther(price)} ETH`,
          status: 'info',
          duration: 3000,
          isClosable: true,
        })
      }
      
      this.onCreditListed?.({
        seller,
        amount: parseFloat(ethers.formatEther(amount)),
        price: parseFloat(ethers.formatEther(price)),
        transactionHash: event.transactionHash
      })
    }
    
    this.contract.on(listingFilter, this.listeners.listing)
  }

  // 停止所有监听
  stopListening() {
    Object.keys(this.listeners).forEach(key => {
      this.contract.removeAllListeners()
    })
    this.listeners = {}
  }

  // 回调函数接口
  onEmissionRecorded?: (data: any) => void
  onCreditPurchased?: (data: any) => void
  onCreditSold?: (data: any) => void
  onCreditListed?: (data: any) => void
}
```

#### 在Web3Context中集成事件监听

```typescript
// src/contexts/Web3Context.tsx - 添加事件监听

import { EventListenerService } from '../services/eventListenerService'

export const Web3Provider = ({ children }: Web3ProviderProps) => {
  // ... 现有状态
  const [eventListener, setEventListener] = useState<EventListenerService | null>(null)

  // 当合约和账户都可用时，启动事件监听
  useEffect(() => {
    if (contract && account) {
      const listener = new EventListenerService(contract, account)
      
      // 设置回调函数
      listener.onEmissionRecorded = (data) => {
        console.log('排放记录事件回调:', data)
        // 可以在这里触发全局状态更新
      }
      
      listener.onCreditPurchased = (data) => {
        console.log('购买事件回调:', data)
        // 更新用户余额等
      }
      
      listener.onCreditSold = (data) => {
        console.log('销售事件回调:', data)
        // 更新用户余额等
      }
      
      listener.onCreditListed = (data) => {
        console.log('上架事件回调:', data)
        // 刷新市场数据
      }
      
      listener.startListening()
      setEventListener(listener)
      
      return () => {
        listener.stopListening()
      }
    }
  }, [contract, account])

  // 断开连接时停止监听
  const disconnectWallet = () => {
    if (eventListener) {
      eventListener.stopListening()
      setEventListener(null)
    }
    
    setAccount(null)
    setChainId(null)
    setProvider(null)
    setSigner(null)
    setContract(null)
  }

  // ... 其余代码
}
```

### 2.2 实现完整的数据同步机制

#### 创建区块链数据同步服务

```typescript
// src/services/blockchainSyncService.ts - 新建文件

import { ethers } from 'ethers'
import { getUserData, saveUserData, UserData } from './userDataService'

export class BlockchainSyncService {
  private contract: ethers.Contract
  private account: string
  private syncInterval: NodeJS.Timeout | null = null

  constructor(contract: ethers.Contract, account: string) {
    this.contract = contract
    this.account = account
  }

  // 启动定期同步
  startPeriodicSync(intervalMs: number = 30000) { // 默认30秒同步一次
    this.syncInterval = setInterval(() => {
      this.syncAllData()
    }, intervalMs)
    
    // 立即执行一次同步
    this.syncAllData()
  }

  // 停止定期同步
  stopPeriodicSync() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval)
      this.syncInterval = null
    }
  }

  // 同步所有数据
  async syncAllData() {
    try {
      console.log('🔄 开始同步区块链数据...')
      
      const [carbonCredits, totalEmissions, transactions] = await Promise.all([
        this.syncCarbonCredits(),
        this.syncTotalEmissions(),
        this.syncTransactionHistory()
      ])

      // 更新本地存储
      const userData: UserData = {
        carbonCredits,
        totalEmissions,
        transactions
      }
      
      saveUserData(this.account, userData)
      console.log('✅ 数据同步完成:', userData)
      
      return userData
    } catch (error) {
      console.error('❌ 数据同步失败:', error)
      throw error
    }
  }

  // 同步碳信用余额
  private async syncCarbonCredits(): Promise<number> {
    try {
      const balance = await this.contract.balanceOf(this.account)
      return parseFloat(ethers.formatEther(balance))
    } catch (error) {
      console.error('同步碳信用余额失败:', error)
      return 0
    }
  }

  // 同步总排放量
  private async syncTotalEmissions(): Promise<number> {
    try {
      const emissions = await this.contract.getUserEmissions()
      return emissions.reduce((total: number, emission: any) => {
        return total + parseFloat(ethers.formatEther(emission.amount))
      }, 0)
    } catch (error) {
      console.error('同步总排放量失败:', error)
      return 0
    }
  }

  // 同步交易历史
  private async syncTransactionHistory(): Promise<any[]> {
    try {
      const transactions: any[] = []
      
      // 获取购买事件
      const purchaseFilter = this.contract.filters.CreditPurchased(this.account, null, null, null)
      const purchaseEvents = await this.contract.queryFilter(purchaseFilter, -10000) // 查询最近10000个区块
      
      for (const event of purchaseEvents) {
        const block = await event.getBlock()
        transactions.push({
          id: event.transactionHash,
          type: 'buy',
          amount: parseFloat(ethers.formatEther(event.args.amount)),
          price: parseFloat(ethers.formatEther(event.args.price)),
          date: new Date(block.timestamp * 1000).toISOString(),
          counterparty: event.args.seller,
          txHash: event.transactionHash,
          status: 'confirmed',
          blockNumber: event.blockNumber
        })
      }
      
      // 获取销售事件
      const saleFilter = this.contract.filters.CreditPurchased(null, this.account, null, null)
      const saleEvents = await this.contract.queryFilter(saleFilter, -10000)
      
      for (const event of saleEvents) {
        const block = await event.getBlock()
        transactions.push({
          id: event.transactionHash,
          type: 'sell',
          amount: parseFloat(ethers.formatEther(event.args.amount)),
          price: parseFloat(ethers.formatEther(event.args.price)),
          date: new Date(block.timestamp * 1000).toISOString(),
          counterparty: event.args.buyer,
          txHash: event.transactionHash,
          status: 'confirmed',
          blockNumber: event.blockNumber
        })
      }
      
      // 按时间排序
      return transactions.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
      
    } catch (error) {
      console.error('同步交易历史失败:', error)
      return []
    }
  }

  // 手动触发同步
  async forcSync() {
    return this.syncAllData()
  }
}
```

### 2.3 优化用户体验

#### 添加加载状态和进度指示

```typescript
// src/components/LoadingStates.tsx - 新建文件

import React from 'react'
import {
  Box,
  Spinner,
  Text,
  Progress,
  VStack,
  HStack,
  Icon
} from '@chakra-ui/react'
import { CheckCircleIcon, WarningIcon } from '@chakra-ui/icons'

interface TransactionStatusProps {
  status: 'idle' | 'sending' | 'pending' | 'confirmed' | 'failed'
  txHash?: string
  description?: string
}

export const TransactionStatus: React.FC<TransactionStatusProps> = ({
  status,
  txHash,
  description
}) => {
  const getStatusConfig = () => {
    switch (status) {
      case 'sending':
        return {
          color: 'blue.500',
          icon: <Spinner size="sm" />,
          text: '发送交易中...',
          progress: 25
        }
      case 'pending':
        return {
          color: 'yellow.500',
          icon: <Spinner size="sm" />,
          text: '等待区块确认...',
          progress: 75
        }
      case 'confirmed':
        return {
          color: 'green.500',
          icon: <CheckCircleIcon />,
          text: '交易已确认',
          progress: 100
        }
      case 'failed':
        return {
          color: 'red.500',
          icon: <WarningIcon />,
          text: '交易失败',
          progress: 0
        }
      default:
        return null
    }
  }

  const config = getStatusConfig()
  if (!config) return null

  return (
    <Box p={4} borderWidth={1} borderRadius="md" bg="gray.50">
      <VStack spacing={3} align="stretch">
        <HStack>
          <Icon as={() => config.icon} color={config.color} />
          <Text fontWeight="medium" color={config.color}>
            {config.text}
          </Text>
        </HStack>
        
        {description && (
          <Text fontSize="sm" color="gray.600">
            {description}
          </Text>
        )}
        
        <Progress value={config.progress} colorScheme={config.color.split('.')[0]} size="sm" />
        
        {txHash && (
          <Text fontSize="xs" color="gray.500" fontFamily="mono">
            交易哈希: {txHash.substring(0, 10)}...{txHash.substring(txHash.length - 8)}
          </Text>
        )}
      </VStack>
    </Box>
  )
}

// 数据同步状态组件
interface SyncStatusProps {
  isSync: boolean
  lastSyncTime?: Date
  onForceSync?: () => void
}

export const SyncStatus: React.FC<SyncStatusProps> = ({
  isSync,
  lastSyncTime,
  onForceSync
}) => {
  return (
    <HStack spacing={2} fontSize="sm" color="gray.600">
      {isSync ? (
        <>
          <Spinner size="xs" />
          <Text>同步中...</Text>
        </>
      ) : (
        <>
          <CheckCircleIcon color="green.500" />
          <Text>
            已同步 {lastSyncTime ? `(${lastSyncTime.toLocaleTimeString()})` : ''}
          </Text>
          {onForceSync && (
            <Text
              as="button"
              color="blue.500"
              textDecoration="underline"
              onClick={onForceSync}
            >
              手动同步
            </Text>
          )}
        </>
      )}
    </HStack>
  )
}
```

## 3. 长期改进方案（3-6个月内完成）

### 3.1 智能合约安全性增强

#### 安全合约模板

```solidity
// contracts/CarbonCreditSystemV2.sol - 安全增强版本

pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract CarbonCreditSystemV2 is ReentrancyGuard, Pausable, Ownable {
    using SafeMath for uint256;

    // 事件定义
    event EmissionRecorded(address indexed user, uint256 amount, string activity, uint256 timestamp);
    event CreditMinted(address indexed to, uint256 amount, string reason);
    event CreditPurchased(address indexed buyer, address indexed seller, uint256 amount, uint256 price);
    event CreditListed(address indexed seller, uint256 listingId, uint256 amount, uint256 price);
    event ListingCancelled(address indexed seller, uint256 listingId);

    // 数据结构
    struct EmissionRecord {
        uint256 amount;
        uint256 timestamp;
        string activity;
        bool verified;  // 是否已验证
    }

    struct CreditListing {
        address seller;
        uint256 amount;
        uint256 price;
        bool active;
        uint256 createdAt;
        uint256 expiresAt;  // 过期时间
    }

    // 状态变量
    mapping(address => uint256) public carbonCredits;
    mapping(address => EmissionRecord[]) public userEmissions;
    mapping(address => bool) public verifiers;  // 验证者权限
    CreditListing[] public listings;
    
    // 配置参数
    uint256 public constant MAX_LISTING_DURATION = 30 days;
    uint256 public constant MIN_CREDIT_AMOUNT = 1e15;  // 0.001 ETH worth
    uint256 public tradingFeeRate = 250;  // 2.5% (basis points)
    address public feeRecipient;

    constructor() {
        feeRecipient = msg.sender;
    }

    // 修饰符
    modifier onlyVerifier() {
        require(verifiers[msg.sender] || msg.sender == owner(), "Not authorized verifier");
        _;
    }

    modifier validAmount(uint256 amount) {
        require(amount >= MIN_CREDIT_AMOUNT, "Amount too small");
        _;
    }

    // 管理功能
    function addVerifier(address verifier) external onlyOwner {
        verifiers[verifier] = true;
    }

    function removeVerifier(address verifier) external onlyOwner {
        verifiers[verifier] = false;
    }

    function setTradingFeeRate(uint256 newRate) external onlyOwner {
        require(newRate <= 1000, "Fee rate too high");  // 最大10%
        tradingFeeRate = newRate;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    // 核心功能
    function recordEmission(uint256 amount, string memory activity) 
        external 
        whenNotPaused 
        validAmount(amount) 
    {
        EmissionRecord memory newRecord = EmissionRecord({
            amount: amount,
            timestamp: block.timestamp,
            activity: activity,
            verified: false
        });
        
        userEmissions[msg.sender].push(newRecord);
        
        emit EmissionRecorded(msg.sender, amount, activity, block.timestamp);
    }

    function verifyEmission(address user, uint256 recordIndex) 
        external 
        onlyVerifier 
    {
        require(recordIndex < userEmissions[user].length, "Invalid record index");
        userEmissions[user][recordIndex].verified = true;
    }

    function mintCredits(address to, uint256 amount, string memory reason) 
        external 
        onlyVerifier 
        validAmount(amount) 
    {
        carbonCredits[to] = carbonCredits[to].add(amount);
        emit CreditMinted(to, amount, reason);
    }

    function listCredit(uint256 amount, uint256 price) 
        external 
        whenNotPaused 
        validAmount(amount) 
        nonReentrant 
    {
        require(carbonCredits[msg.sender] >= amount, "Insufficient credits");
        require(price > 0, "Invalid price");
        
        // 冻结碳信用
        carbonCredits[msg.sender] = carbonCredits[msg.sender].sub(amount);
        
        uint256 listingId = listings.length;
        listings.push(CreditListing({
            seller: msg.sender,
            amount: amount,
            price: price,
            active: true,
            createdAt: block.timestamp,
            expiresAt: block.timestamp.add(MAX_LISTING_DURATION)
        }));
        
        emit CreditListed(msg.sender, listingId, amount, price);
    }

    function buyCredit(uint256 listingId) 
        external 
        payable 
        whenNotPaused 
        nonReentrant 
    {
        require(listingId < listings.length, "Invalid listing");
        
        CreditListing storage listing = listings[listingId];
        require(listing.active, "Listing not active");
        require(block.timestamp <= listing.expiresAt, "Listing expired");
        require(msg.sender != listing.seller, "Cannot buy own listing");
        
        uint256 totalPrice = listing.amount.mul(listing.price);
        require(msg.value >= totalPrice, "Insufficient payment");
        
        // 计算手续费
        uint256 fee = totalPrice.mul(tradingFeeRate).div(10000);
        uint256 sellerAmount = totalPrice.sub(fee);
        
        // 更新状态
        listing.active = false;
        carbonCredits[msg.sender] = carbonCredits[msg.sender].add(listing.amount);
        
        // 转账
        (bool success1, ) = payable(listing.seller).call{value: sellerAmount}("");
        require(success1, "Transfer to seller failed");
        
        (bool success2, ) = payable(feeRecipient).call{value: fee}("");
        require(success2, "Fee transfer failed");
        
        // 退还多余金额
        if (msg.value > totalPrice) {
            (bool success3, ) = payable(msg.sender).call{value: msg.value.sub(totalPrice)}("");
            require(success3, "Refund failed");
        }
        
        emit CreditPurchased(msg.sender, listing.seller, listing.amount, totalPrice);
    }

    function cancelListing(uint256 listingId) 
        external 
        nonReentrant 
    {
        require(listingId < listings.length, "Invalid listing");
        
        CreditListing storage listing = listings[listingId];
        require(listing.seller == msg.sender, "Not listing owner");
        require(listing.active, "Listing not active");
        
        // 退还碳信用
        listing.active = false;
        carbonCredits[msg.sender] = carbonCredits[msg.sender].add(listing.amount);
        
        emit ListingCancelled(msg.sender, listingId);
    }

    // 查询功能
    function getUserEmissions() external view returns (EmissionRecord[] memory) {
        return userEmissions[msg.sender];
    }

    function getActiveListings() external view returns (CreditListing[] memory) {
        uint256 activeCount = 0;
        
        // 计算活跃上架数量
        for (uint256 i = 0; i < listings.length; i++) {
            if (listings[i].active && block.timestamp <= listings[i].expiresAt) {
                activeCount++;
            }
        }
        
        // 创建活跃上架数组
        CreditListing[] memory activeListings = new CreditListing[](activeCount);
        uint256 index = 0;
        
        for (uint256 i = 0; i < listings.length; i++) {
            if (listings[i].active && block.timestamp <= listings[i].expiresAt) {
                activeListings[index] = listings[i];
                index++;
            }
        }
        
        return activeListings;
    }

    function balanceOf(address account) external view returns (uint256) {
        return carbonCredits[account];
    }

    // 紧急功能
    function emergencyWithdraw() external onlyOwner {
        (bool success, ) = payable(owner()).call{value: address(this).balance}("");
        require(success, "Emergency withdraw failed");
    }
}
```

### 3.2 多链支持

#### 跨链桥接合约

```solidity
// contracts/CarbonCreditBridge.sol

pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract CarbonCreditBridge is ReentrancyGuard, Ownable {
    // 跨链转移事件
    event CrossChainTransferInitiated(
        address indexed from,
        uint256 amount,
        uint256 targetChainId,
        bytes32 transferId
    );
    
    event CrossChainTransferCompleted(
        address indexed to,
        uint256 amount,
        uint256 sourceChainId,
        bytes32 transferId
    );
    
    // 支持的链
    mapping(uint256 => bool) public supportedChains;
    mapping(bytes32 => bool) public processedTransfers;
    
    // 验证者
    mapping(address => bool) public validators;
    uint256 public requiredValidations = 2;
    
    struct CrossChainTransfer {
        address from;
        address to;
        uint256 amount;
        uint256 sourceChainId;
        uint256 targetChainId;
        uint256 validations;
        bool completed;
    }
    
    mapping(bytes32 => CrossChainTransfer) public transfers;
    mapping(bytes32 => mapping(address => bool)) public transferValidations;
    
    // 主合约接口
    interface ICarbonCreditSystem {
        function burnCredits(address from, uint256 amount) external;
        function mintCredits(address to, uint256 amount, string memory reason) external;
    }
    
    ICarbonCreditSystem public carbonContract;
    
    constructor(address _carbonContract) {
        carbonContract = ICarbonCreditSystem(_carbonContract);
    }
    
    // 发起跨链转移
    function initiateCrossChainTransfer(
        uint256 amount,
        uint256 targetChainId,
        address targetAddress
    ) external nonReentrant {
        require(supportedChains[targetChainId], "Target chain not supported");
        require(amount > 0, "Invalid amount");
        
        bytes32 transferId = keccak256(abi.encodePacked(
            msg.sender,
            targetAddress,
            amount,
            block.chainid,
            targetChainId,
            block.timestamp
        ));
        
        // 销毁源链上的碳信用
        carbonContract.burnCredits(msg.sender, amount);
        
        transfers[transferId] = CrossChainTransfer({
            from: msg.sender,
            to: targetAddress,
            amount: amount,
            sourceChainId: block.chainid,
            targetChainId: targetChainId,
            validations: 0,
            completed: false
        });
        
        emit CrossChainTransferInitiated(msg.sender, amount, targetChainId, transferId);
    }
    
    // 验证跨链转移
    function validateTransfer(bytes32 transferId) external {
        require(validators[msg.sender], "Not a validator");
        require(!transferValidations[transferId][msg.sender], "Already validated");
        require(!transfers[transferId].completed, "Transfer already completed");
        
        transferValidations[transferId][msg.sender] = true;
        transfers[transferId].validations++;
        
        // 如果达到所需验证数量，完成转移
        if (transfers[transferId].validations >= requiredValidations) {
            completeTransfer(transferId);
        }
    }
    
    // 完成跨链转移
    function completeTransfer(bytes32 transferId) internal {
        CrossChainTransfer storage transfer = transfers[transferId];
        require(!transfer.completed, "Transfer already completed");
        
        transfer.completed = true;
        
        // 在目标链上铸造碳信用
        carbonContract.mintCredits(
            transfer.to,
            transfer.amount,
            "Cross-chain transfer"
        );
        
        emit CrossChainTransferCompleted(
            transfer.to,
            transfer.amount,
            transfer.sourceChainId,
            transferId
        );
    }
}
```

### 3.3 高级DeFi功能集成

#### 碳信用质押和流动性挖矿

```solidity
// contracts/CarbonCreditStaking.sol

pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract CarbonCreditStaking is ReentrancyGuard {
    using SafeMath for uint256;
    
    IERC20 public carbonToken;  // 碳信用代币
    IERC20 public rewardToken;  // 奖励代币
    
    struct StakeInfo {
        uint256 amount;
        uint256 rewardDebt;
        uint256 stakingTime;
    }
    
    mapping(address => StakeInfo) public stakes;
    
    uint256 public totalStaked;
    uint256 public rewardPerSecond;
    uint256 public accRewardPerShare;
    uint256 public lastRewardTime;
    
    event Staked(address indexed user, uint256 amount);
    event Unstaked(address indexed user, uint256 amount);
    event RewardClaimed(address indexed user, uint256 amount);
    
    constructor(
        address _carbonToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) {
        carbonToken = IERC20(_carbonToken);
        rewardToken = IERC20(_rewardToken);
        rewardPerSecond = _rewardPerSecond;
        lastRewardTime = block.timestamp;
    }
    
    // 质押碳信用
    function stake(uint256 amount) external nonReentrant {
        require(amount > 0, "Cannot stake 0");
        
        updatePool();
        
        StakeInfo storage userStake = stakes[msg.sender];
        
        // 如果用户已有质押，先领取奖励
        if (userStake.amount > 0) {
            uint256 pending = userStake.amount.mul(accRewardPerShare).div(1e12).sub(userStake.rewardDebt);
            if (pending > 0) {
                rewardToken.transfer(msg.sender, pending);
                emit RewardClaimed(msg.sender, pending);
            }
        }
        
        // 转移碳信用到合约
        carbonToken.transferFrom(msg.sender, address(this), amount);
        
        // 更新质押信息
        userStake.amount = userStake.amount.add(amount);
        userStake.stakingTime = block.timestamp;
        userStake.rewardDebt = userStake.amount.mul(accRewardPerShare).div(1e12);
        
        totalStaked = totalStaked.add(amount);
        
        emit Staked(msg.sender, amount);
    }
    
    // 取消质押
    function unstake(uint256 amount) external nonReentrant {
        StakeInfo storage userStake = stakes[msg.sender];
        require(userStake.amount >= amount, "Insufficient staked amount");
        
        updatePool();
        
        // 计算并发放奖励
        uint256 pending = userStake.amount.mul(accRewardPerShare).div(1e12).sub(userStake.rewardDebt);
        if (pending > 0) {
            rewardToken.transfer(msg.sender, pending);
            emit RewardClaimed(msg.sender, pending);
        }
        
        // 更新质押信息
        userStake.amount = userStake.amount.sub(amount);
        userStake.rewardDebt = userStake.amount.mul(accRewardPerShare).div(1e12);
        
        totalStaked = totalStaked.sub(amount);
        
        // 返还碳信用
        carbonToken.transfer(msg.sender, amount);
        
        emit Unstaked(msg.sender, amount);
    }
    
    // 领取奖励
    function claimReward() external nonReentrant {
        updatePool();
        
        StakeInfo storage userStake = stakes[msg.sender];
        uint256 pending = userStake.amount.mul(accRewardPerShare).div(1e12).sub(userStake.rewardDebt);
        
        require(pending > 0, "No pending rewards");
        
        userStake.rewardDebt = userStake.amount.mul(accRewardPerShare).div(1e12);
        rewardToken.transfer(msg.sender, pending);
        
        emit RewardClaimed(msg.sender, pending);
    }
    
    // 更新奖励池
    function updatePool() public {
        if (block.timestamp <= lastRewardTime) {
            return;
        }
        
        if (totalStaked == 0) {
            lastRewardTime = block.timestamp;
            return;
        }
        
        uint256 timeElapsed = block.timestamp.sub(lastRewardTime);
        uint256 reward = timeElapsed.mul(rewardPerSecond);
        accRewardPerShare = accRewardPerShare.add(reward.mul(1e12).div(totalStaked));
        lastRewardTime = block.timestamp;
    }
    
    // 查询待领取奖励
    function pendingReward(address user) external view returns (uint256) {
        StakeInfo storage userStake = stakes[user];
        uint256 tempAccRewardPerShare = accRewardPerShare;
        
        if (block.timestamp > lastRewardTime && totalStaked != 0) {
            uint256 timeElapsed = block.timestamp.sub(lastRewardTime);
            uint256 reward = timeElapsed.mul(rewardPerSecond);
            tempAccRewardPerShare = tempAccRewardPerShare.add(reward.mul(1e12).div(totalStaked));
        }
        
        return userStake.amount.mul(tempAccRewardPerShare).div(1e12).sub(userStake.rewardDebt);
    }
}
```

## 4. 部署和测试指南

### 4.1 测试网部署步骤

```bash
# 1. 安装依赖
npm install --save-dev hardhat @nomiclabs/hardhat-ethers ethers

# 2. 创建Hardhat配置
# hardhat.config.js
require("@nomiclabs/hardhat-ethers");

module.exports = {
  solidity: "0.8.19",
  networks: {
    sepolia: {
      url: "https://sepolia.infura.io/v3/YOUR_PROJECT_ID",
      accounts: ["YOUR_PRIVATE_KEY"]
    },
    localhost: {
      url: "http://127.0.0.1:8545"
    }
  }
};

# 3. 创建部署脚本
# scripts/deploy.js
const { ethers } = require("hardhat");

async function main() {
  console.log("开始部署碳信用系统合约...");
  
  // 部署主合约
  const CarbonCreditSystem = await ethers.getContractFactory("CarbonCreditSystemV2");
  const carbonContract = await CarbonCreditSystem.deploy();
  await carbonContract.deployed();
  
  console.log("碳信用系统合约已部署到:", carbonContract.address);
  
  // 部署质押合约（如果需要）
  const StakingContract = await ethers.getContractFactory("CarbonCreditStaking");
  const stakingContract = await StakingContract.deploy(
    carbonContract.address,  // 碳信用代币地址
    carbonContract.address,  // 奖励代币地址（暂时使用同一个）
    ethers.utils.parseEther("0.1")  // 每秒奖励数量
  );
  await stakingContract.deployed();
  
  console.log("质押合约已部署到:", stakingContract.address);
  
  // 保存合约地址
  const addresses = {
    carbonContract: carbonContract.address,
    stakingContract: stakingContract.address,
    network: "sepolia",
    deployTime: new Date().toISOString()
  };
  
  console.log("部署完成:", addresses);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

# 4. 执行部署
npx hardhat run scripts/deploy.js --network sepolia
```

### 4.2 前端集成测试

```typescript
// src/utils/contractTesting.ts - 合约测试工具

import { ethers } from 'ethers'
import CarbonCreditSystemABI from '../contracts/CarbonCreditSystem.json'

export class ContractTester {
  private contract: ethers.Contract
  private signer: ethers.Signer

  constructor(contractAddress: string, signer: ethers.Signer) {
    this.contract = new ethers.Contract(contractAddress, CarbonCreditSystemABI, signer)
    this.signer = signer
  }

  // 测试排放记录功能
  async testEmissionRecording() {
    console.log('🧪 测试排放记录功能...')
    
    try {
      // 记录排放
      const tx = await this.contract.recordEmission(
        ethers.parseEther('2.5'),
        '测试排放活动'
      )
      const receipt = await tx.wait()
      console.log('✅ 排放记录成功:', receipt.hash)
      
      // 获取排放记录
      const emissions = await this.contract.getUserEmissions()
      console.log('📊 用户排放记录:', emissions)
      
      return true
    } catch (error) {
      console.error('❌ 排放记录测试失败:', error)
      return false
    }
  }

  // 测试碳信用交易功能
  async testCreditTrading() {
    console.log('🧪 测试碳信用交易功能...')
    
    try {
      // 首先需要有碳信用余额（通过管理员铸造）
      const balance = await this.contract.balanceOf(await this.signer.getAddress())
      console.log('💰 当前碳信用余额:', ethers.formatEther(balance))
      
      if (balance.gt(0)) {
        // 测试上架
        const listTx = await this.contract.listCredit(
          ethers.parseEther('1'),
          ethers.parseEther('0.01')
        )
        await listTx.wait()
        console.log('✅ 碳信用上架成功')
        
        // 获取市场数据
        const listings = await this.contract.getActiveListings()
        console.log('🏪 市场上架数据:', listings)
      } else {
        console.log('⚠️ 余额不足，跳过交易测试')
      }
      
      return true
    } catch (error) {
      console.error('❌ 交易测试失败:', error)
      return false
    }
  }

  // 测试事件监听
  async testEventListening() {
    console.log('🧪 测试事件监听功能...')
    
    return new Promise((resolve) => {
      let eventReceived = false
      
      // 设置事件监听器
      this.contract.once('EmissionRecorded', (user, amount, activity) => {
        console.log('📡 接收到排放记录事件:', {
          user,
          amount: ethers.formatEther(amount),
          activity
        })
        eventReceived = true
        resolve(true)
      })
      
      // 触发事件
      this.contract.recordEmission(
        ethers.parseEther('1'),
        '事件测试'
      ).then(tx => tx.wait())
      
      // 超时处理
      setTimeout(() => {
        if (!eventReceived) {
          console.log('⚠️ 事件监听超时')
          resolve(false)
        }
      }, 30000)
    })
  }

  // 运行所有测试
  async runAllTests() {
    console.log('🚀 开始运行合约集成测试...')
    
    const results = {
      emission: await this.testEmissionRecording(),
      trading: await this.testCreditTrading(),
      events: await this.testEventListening()
    }
    
    console.log('📋 测试结果汇总:', results)
    
    const allPassed = Object.values(results).every(result => result)
    console.log(allPassed ? '🎉 所有测试通过!' : '⚠️ 部分测试失败')
    
    return results
  }
}
```

### 4.3 性能监控和优化

```typescript
// src/utils/performanceMonitor.ts - 性能监控工具

export class PerformanceMonitor {
  private metrics: { [key: string]: number[] } = {}
  private gasUsage: { [key: string]: number[] } = {}

  // 记录交易性能
  recordTransaction(operation: string, gasUsed: number, duration: number) {
    if (!this.metrics[operation]) {
      this.metrics[operation] = []
      this.gasUsage[operation] = []
    }
    
    this.metrics[operation].push(duration)
    this.gasUsage[operation].push(gasUsed)
    
    console.log(`📊 ${operation} 性能:`, {
      duration: `${duration}ms`,
      gasUsed: gasUsed.toLocaleString(),
      avgDuration: this.getAverageMetric(operation),
      avgGas: this.getAverageGas(operation)
    })
  }

  // 获取平均响应时间
  getAverageMetric(operation: string): number {
    const metrics = this.metrics[operation]
    if (!metrics || metrics.length === 0) return 0
    return metrics.reduce((sum, val) => sum + val, 0) / metrics.length
  }

  // 获取平均Gas消耗
  getAverageGas(operation: string): number {
    const gasUsage = this.gasUsage[operation]
    if (!gasUsage || gasUsage.length === 0) return 0
    return gasUsage.reduce((sum, val) => sum + val, 0) / gasUsage.length
  }

  // 生成性能报告
  generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      operations: {} as any
    }
    
    Object.keys(this.metrics).forEach(operation => {
      report.operations[operation] = {
        totalCalls: this.metrics[operation].length,
        averageResponseTime: Math.round(this.getAverageMetric(operation)),
        averageGasUsage: Math.round(this.getAverageGas(operation)),
        minResponseTime: Math.min(...this.metrics[operation]),
        maxResponseTime: Math.max(...this.metrics[operation]),
        minGasUsage: Math.min(...this.gasUsage[operation]),
        maxGasUsage: Math.max(...this.gasUsage[operation])
      }
    })
    
    console.log('📈 性能报告:', report)
    return report
  }

  // 检查性能警告
  checkPerformanceWarnings() {
    const warnings: string[] = []
    
    Object.keys(this.metrics).forEach(operation => {
      const avgTime = this.getAverageMetric(operation)
      const avgGas = this.getAverageGas(operation)
      
      if (avgTime > 10000) { // 超过10秒
        warnings.push(`${operation} 响应时间过长: ${avgTime}ms`)
      }
      
      if (avgGas > 500000) { // 超过50万Gas
        warnings.push(`${operation} Gas消耗过高: ${avgGas.toLocaleString()}`)
      }
    })
    
    if (warnings.length > 0) {
      console.warn('⚠️ 性能警告:', warnings)
    }
    
    return warnings
  }
}

// 全局性能监控实例
export const performanceMonitor = new PerformanceMonitor()

// 装饰器：自动监控合约方法性能
export function monitorPerformance(operationName: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value
    
    descriptor.value = async function (...args: any[]) {
      const startTime = Date.now()
      
      try {
        const result = await method.apply(this, args)
        const duration = Date.now() - startTime
        
        // 如果结果包含Gas信息，记录它
        if (result && result.gasUsed) {
          performanceMonitor.recordTransaction(
            operationName,
            Number(result.gasUsed),
            duration
          )
        } else {
          performanceMonitor.recordTransaction(operationName, 0, duration)
        }
        
        return result
      } catch (error) {
        const duration = Date.now() - startTime
        console.error(`❌ ${operationName} 执行失败 (${duration}ms):`, error)
        throw error
      }
    }
    
    return descriptor
  }
}
```

## 5. 总结和路线图

### 5.1 实施优先级

| 优先级 | 改进项目 | 预计时间 | 技术难度 | 业务价值 |
|--------|----------|----------|----------|----------|
| 🔴 高 | 启用智能合约调用 | 1周 | 低 | 高 |
| 🔴 高 | 配置合约地址 | 2天 | 低 | 高 |
| 🟡 中 | 实现事件监听 | 1-2周 | 中 | 中 |
| 🟡 中 | 数据同步机制 | 2-3周 | 中 | 中 |
| 🟢 低 | 安全性增强 | 1-2月 | 高 | 中 |
| 🟢 低 | 多链支持 | 2-3月 | 高 | 低 |
| 🟢 低 | DeFi功能 | 3-6月 | 高 | 低 |

### 5.2 成功指标

#### 技术指标
- ✅ 所有智能合约方法正常调用
- ✅ 事件监听100%工作
- ✅ 数据同步延迟 < 30秒
- ✅ 交易确认时间 < 2分钟
- ✅ Gas费用优化 > 20%

#### 用户体验指标
- ✅ 页面加载时间 < 3秒
- ✅ 交易成功率 > 95%
- ✅ 错误信息清晰易懂
- ✅ 移动端兼容性良好

#### 业务指标
- ✅ 真实的链上数据存储
- ✅ 去中心化交易功能
- ✅ 透明的排放记录
- ✅ 可审计的交易历史

### 5.3 风险评估和缓解策略

#### 技术风险
1. **智能合约漏洞**
   - 缓解：代码审计、测试网充分测试
   - 应急：暂停机制、升级机制

2. **Gas费用波动**
   - 缓解：Gas费用估算、用户提醒
   - 应急：Layer 2解决方案

3. **网络拥堵**
   - 缓解：多网络支持、优先级队列
   - 应急：离线模式、批量处理

#### 用户体验风险
1. **钱包连接问题**
   - 缓解：详细的连接指南、多钱包支持
   - 应急：客服支持、FAQ文档

2. **交易失败**
   - 缓解：预检查、清晰的错误信息
   - 应急：重试机制、人工处理

### 5.4 下一步行动计划

#### 第1周：立即行动
1. ✅ 修改Emissions.tsx启用智能合约调用
2. ✅ 修改Market.tsx启用智能合约调用
3. ✅ 配置环境变量和合约地址
4. ✅ 基础错误处理实现
5. ✅ 在测试网部署合约

#### 第2-4周：核心功能
1. ✅ 实现事件监听机制
2. ✅ 数据同步服务开发
3. ✅ 性能监控集成
4. ✅ 用户体验优化
5. ✅ 全面测试和调试

#### 第2-3个月：增强功能
1. ✅ 智能合约安全审计
2. ✅ 多链支持开发
3. ✅ 高级DeFi功能
4. ✅ 移动端优化
5. ✅ 生产环境部署

---

**总结：** 这个改进实施方案提供了从立即可行的修复到长期愿景的完整路径。通过分阶段实施，可以快速实现真正的区块链功能，同时为未来的扩展奠定坚实基础。关键是先解决核心的智能合约调用问题，然后逐步增强功能和用户体验。