# åŒºå—é“¾åŠŸèƒ½æ”¹è¿›å®æ–½æ–¹æ¡ˆ

## 1. ç«‹å³å¯è¡Œçš„æ”¹è¿›æ–¹æ¡ˆï¼ˆ1-2å‘¨å†…å®Œæˆï¼‰

### 1.1 å¯ç”¨æ™ºèƒ½åˆçº¦è°ƒç”¨

#### æ­¥éª¤1ï¼šä¿®æ”¹æ’æ”¾è®°å½•é¡µé¢

```typescript
// src/pages/Emissions.tsx - ä¿®æ”¹å»ºè®®

// âŒ å½“å‰çš„æ¨¡æ‹Ÿå®ç°
const handleSubmit = async (e: React.FormEvent) => {
  // ... çœç•¥éªŒè¯ä»£ç 
  
  try {
    setIsSubmitting(true)
    
    // æ³¨é‡Šæ‰çš„æ™ºèƒ½åˆçº¦è°ƒç”¨
    // await contract.recordEmission(parseFloat(amount), activity)
    
    // æ¨¡æ‹Ÿå»¶è¿Ÿ
    setTimeout(() => {
      // æœ¬åœ°çŠ¶æ€æ›´æ–°
    }, 2000)
  }
}

// âœ… ä¿®æ”¹åçš„åŒºå—é“¾å®ç°
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault()
  
  if (!activity || !amount) {
    toast({
      title: 'è¯·å¡«å†™å®Œæ•´ä¿¡æ¯',
      status: 'warning',
      duration: 3000,
      isClosable: true,
    })
    return
  }

  // æ£€æŸ¥åˆçº¦å’Œé’±åŒ…è¿æ¥
  if (!contract || !account) {
    toast({
      title: 'è¯·å…ˆè¿æ¥é’±åŒ…',
      status: 'warning',
      duration: 3000,
      isClosable: true,
    })
    return
  }

  try {
    setIsSubmitting(true)
    
    // âœ… è°ƒç”¨çœŸå®çš„æ™ºèƒ½åˆçº¦æ–¹æ³•
    const tx = await contract.recordEmission(
      ethers.parseEther(amount),  // è½¬æ¢ä¸ºWeiå•ä½
      activity                    // æ´»åŠ¨ç±»å‹
    )
    
    // æ˜¾ç¤ºäº¤æ˜“å·²å‘é€çš„æç¤º
    toast({
      title: 'äº¤æ˜“å·²å‘é€',
      description: `äº¤æ˜“å“ˆå¸Œ: ${tx.hash.substring(0, 10)}...`,
      status: 'info',
      duration: 3000,
      isClosable: true,
    })
    
    // ç­‰å¾…äº¤æ˜“ç¡®è®¤
    const receipt = await tx.wait()
    
    // äº¤æ˜“æˆåŠŸåçš„å¤„ç†
    if (receipt.status === 1) {
      // ä»åŒºå—é“¾é‡æ–°è·å–æ•°æ®
      await refreshEmissionsFromBlockchain()
      
      // é‡ç½®è¡¨å•
      setActivity('')
      setAmount('')
      
      toast({
        title: 'æ’æ”¾è®°å½•å·²ä¸Šé“¾',
        description: `åŒºå—å·: ${receipt.blockNumber}`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
    } else {
      throw new Error('äº¤æ˜“å¤±è´¥')
    }
    
  } catch (error: any) {
    console.error('è®°å½•å¤±è´¥:', error)
    
    // è¯¦ç»†çš„é”™è¯¯å¤„ç†
    let errorMessage = 'è¯·ç¨åé‡è¯•'
    if (error.code === 'INSUFFICIENT_FUNDS') {
      errorMessage = 'ETHä½™é¢ä¸è¶³ï¼Œæ— æ³•æ”¯ä»˜Gasè´¹ç”¨'
    } else if (error.code === 'USER_REJECTED') {
      errorMessage = 'ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“'
    } else if (error.message?.includes('execution reverted')) {
      errorMessage = 'æ™ºèƒ½åˆçº¦æ‰§è¡Œå¤±è´¥ï¼Œè¯·æ£€æŸ¥å‚æ•°'
    }
    
    toast({
      title: 'è®°å½•å¤±è´¥',
      description: errorMessage,
      status: 'error',
      duration: 3000,
      isClosable: true,
    })
  } finally {
    setIsSubmitting(false)
  }
}

// âœ… æ–°å¢ï¼šä»åŒºå—é“¾åˆ·æ–°æ’æ”¾æ•°æ®
const refreshEmissionsFromBlockchain = async () => {
  try {
    if (contract) {
      const blockchainEmissions = await contract.getUserEmissions()
      
      const formattedEmissions = blockchainEmissions.map((emission: any, index: number) => ({
        id: index + 1,
        activity: emission.activity,
        amount: parseFloat(ethers.formatEther(emission.amount)),
        timestamp: Number(emission.timestamp) * 1000  // è½¬æ¢ä¸ºæ¯«ç§’
      }))
      
      setEmissions(formattedEmissions)
    }
  } catch (error) {
    console.error('åˆ·æ–°æ’æ”¾æ•°æ®å¤±è´¥:', error)
  }
}

// âœ… æ–°å¢ï¼šé¡µé¢åŠ è½½æ—¶ä»åŒºå—é“¾è·å–æ•°æ®
useEffect(() => {
  if (contract && account) {
    refreshEmissionsFromBlockchain()
  }
}, [contract, account])
```

#### æ­¥éª¤2ï¼šä¿®æ”¹å¸‚åœºäº¤æ˜“é¡µé¢

```typescript
// src/pages/Market.tsx - ä¿®æ”¹å»ºè®®

// âœ… ä¿®æ”¹è´­ä¹°åŠŸèƒ½
const handleBuy = async (listingId: number, price: number, amount: number, seller: string) => {
  if (!signer || !contract) {
    toast({
      title: 'è¯·å…ˆè¿æ¥é’±åŒ…',
      status: 'warning',
      duration: 3000,
      isClosable: true,
    })
    return
  }

  try {
    setBuyingId(listingId)
    
    // âœ… è°ƒç”¨æ™ºèƒ½åˆçº¦çš„buyCreditæ–¹æ³•
    const totalPrice = price * amount
    const tx = await contract.buyCredit(listingId, {
      value: ethers.parseEther(totalPrice.toString())
    })
    
    toast({
      title: 'äº¤æ˜“å·²å‘é€',
      description: `äº¤æ˜“å“ˆå¸Œ: ${tx.hash.substring(0, 10)}...`,
      status: 'info',
      duration: 3000,
      isClosable: true,
    })
    
    const receipt = await tx.wait()
    
    if (receipt.status === 1) {
      // ä»åŒºå—é“¾é‡æ–°è·å–å¸‚åœºæ•°æ®
      await refreshMarketDataFromBlockchain()
      
      // æ›´æ–°ç”¨æˆ·ä½™é¢
      await updateUserBalance()
      
      toast({
        title: 'è´­ä¹°æˆåŠŸ',
        description: `å·²è´­ä¹° ${amount} ä¸ªç¢³ä¿¡ç”¨`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
    }
    
  } catch (error: any) {
    console.error('è´­ä¹°å¤±è´¥:', error)
    
    let errorMessage = 'è¯·ç¨åé‡è¯•'
    if (error.code === 'INSUFFICIENT_FUNDS') {
      errorMessage = 'ETHä½™é¢ä¸è¶³'
    } else if (error.code === 'USER_REJECTED') {
      errorMessage = 'ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“'
    } else if (error.message?.includes('listing not active')) {
      errorMessage = 'è¯¥ç¢³ä¿¡ç”¨å·²è¢«è´­ä¹°'
    }
    
    toast({
      title: 'è´­ä¹°å¤±è´¥',
      description: errorMessage,
      status: 'error',
      duration: 3000,
      isClosable: true,
    })
  } finally {
    setBuyingId(null)
  }
}

// âœ… ä¿®æ”¹é”€å”®åŠŸèƒ½
const handleSell = async () => {
  if (!contract || !account) {
    toast({
      title: 'è¯·å…ˆè¿æ¥é’±åŒ…',
      status: 'warning',
      duration: 3000,
      isClosable: true,
    })
    return
  }

  try {
    setIsSelling(true)
    
    // âœ… è°ƒç”¨æ™ºèƒ½åˆçº¦çš„listCreditæ–¹æ³•
    const tx = await contract.listCredit(
      ethers.parseEther(amount.toString()),
      ethers.parseEther(price.toString())
    )
    
    toast({
      title: 'ä¸Šæ¶äº¤æ˜“å·²å‘é€',
      description: `äº¤æ˜“å“ˆå¸Œ: ${tx.hash.substring(0, 10)}...`,
      status: 'info',
      duration: 3000,
      isClosable: true,
    })
    
    const receipt = await tx.wait()
    
    if (receipt.status === 1) {
      // ä»åŒºå—é“¾é‡æ–°è·å–å¸‚åœºæ•°æ®
      await refreshMarketDataFromBlockchain()
      
      // é‡ç½®è¡¨å•
      setAmount('')
      setPrice('')
      
      toast({
        title: 'ä¸Šæ¶æˆåŠŸ',
        description: `å·²ä¸Šæ¶ ${amount} ä¸ªç¢³ä¿¡ç”¨`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
    }
    
  } catch (error: any) {
    console.error('ä¸Šæ¶å¤±è´¥:', error)
    
    let errorMessage = 'è¯·ç¨åé‡è¯•'
    if (error.code === 'INSUFFICIENT_FUNDS') {
      errorMessage = 'ETHä½™é¢ä¸è¶³ï¼Œæ— æ³•æ”¯ä»˜Gasè´¹ç”¨'
    } else if (error.code === 'USER_REJECTED') {
      errorMessage = 'ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“'
    } else if (error.message?.includes('insufficient balance')) {
      errorMessage = 'ç¢³ä¿¡ç”¨ä½™é¢ä¸è¶³'
    }
    
    toast({
      title: 'ä¸Šæ¶å¤±è´¥',
      description: errorMessage,
      status: 'error',
      duration: 3000,
      isClosable: true,
    })
  } finally {
    setIsSelling(false)
  }
}

// âœ… æ–°å¢ï¼šä»åŒºå—é“¾åˆ·æ–°å¸‚åœºæ•°æ®
const refreshMarketDataFromBlockchain = async () => {
  try {
    if (contract) {
      const blockchainListings = await contract.getAllListings()
      
      const formattedListings = blockchainListings
        .map((listing: any, index: number) => ({
          id: index,
          seller: listing.seller,
          amount: parseFloat(ethers.formatEther(listing.amount)),
          price: parseFloat(ethers.formatEther(listing.price)),
          active: listing.active
        }))
        .filter((listing: any) => listing.active)  // åªæ˜¾ç¤ºæ´»è·ƒçš„ä¸Šæ¶
      
      setListings(formattedListings)
    }
  } catch (error) {
    console.error('åˆ·æ–°å¸‚åœºæ•°æ®å¤±è´¥:', error)
  }
}

// âœ… æ–°å¢ï¼šæ›´æ–°ç”¨æˆ·ä½™é¢
const updateUserBalance = async () => {
  try {
    if (contract && account) {
      const balance = await contract.balanceOf(account)
      const formattedBalance = parseFloat(ethers.formatEther(balance))
      
      // æ›´æ–°æœ¬åœ°ç”¨æˆ·æ•°æ®
      const userData = getUserData(account)
      userData.carbonCredits = formattedBalance
      saveUserData(account, userData)
    }
  } catch (error) {
    console.error('æ›´æ–°ä½™é¢å¤±è´¥:', error)
  }
}

// âœ… é¡µé¢åŠ è½½æ—¶ä»åŒºå—é“¾è·å–æ•°æ®
useEffect(() => {
  if (contract) {
    refreshMarketDataFromBlockchain()
  }
}, [contract])

useEffect(() => {
  if (contract && account) {
    updateUserBalance()
  }
}, [contract, account])
```

### 1.2 é…ç½®æ™ºèƒ½åˆçº¦åœ°å€

#### æ­¥éª¤1ï¼šåˆ›å»ºç¯å¢ƒé…ç½®æ–‡ä»¶

```bash
# .env.local - åˆ›å»ºç¯å¢ƒå˜é‡æ–‡ä»¶

# æ™ºèƒ½åˆçº¦åœ°å€ï¼ˆéœ€è¦éƒ¨ç½²åè·å¾—ï¼‰
VITE_CONTRACT_ADDRESS=0x1234567890123456789012345678901234567890

# ç½‘ç»œé…ç½®
VITE_CHAIN_ID=11155111  # Sepoliaæµ‹è¯•ç½‘
VITE_NETWORK_NAME=Sepolia
VITE_RPC_URL=https://sepolia.infura.io/v3/YOUR_PROJECT_ID
```

#### æ­¥éª¤2ï¼šä¿®æ”¹Web3Contexté…ç½®æ£€æŸ¥

```typescript
// src/contexts/Web3Context.tsx - æ·»åŠ é…ç½®æ£€æŸ¥

const connectWallet = async () => {
  if (!window.ethereum) {
    alert('è¯·å®‰è£… MetaMask!')
    return
  }

  try {
    setIsConnecting(true)
    
    const browserProvider = new ethers.BrowserProvider(window.ethereum)
    const accounts = await browserProvider.send('eth_requestAccounts', [])
    
    if (accounts.length > 0) {
      const userAccount = accounts[0]
      const userSigner = await browserProvider.getSigner()
      const network = await browserProvider.getNetwork()
      const chainIdentifier = Number(network.chainId)
      
      // âœ… æ£€æŸ¥ç½‘ç»œæ˜¯å¦æ­£ç¡®
      const expectedChainId = parseInt(import.meta.env.VITE_CHAIN_ID || '1')
      if (chainIdentifier !== expectedChainId) {
        toast({
          title: 'ç½‘ç»œé”™è¯¯',
          description: `è¯·åˆ‡æ¢åˆ° ${import.meta.env.VITE_NETWORK_NAME || 'Ethereum'} ç½‘ç»œ`,
          status: 'warning',
          duration: 5000,
          isClosable: true,
        })
        return
      }
      
      setAccount(userAccount)
      setChainId(chainIdentifier)
      setProvider(browserProvider)
      setSigner(userSigner)
      
      // âœ… æ£€æŸ¥åˆçº¦åœ°å€é…ç½®
      const contractAddress = import.meta.env.VITE_CONTRACT_ADDRESS
      if (!contractAddress || contractAddress === '0x1234567890123456789012345678901234567890') {
        console.warn('âš ï¸ æ™ºèƒ½åˆçº¦åœ°å€æœªæ­£ç¡®é…ç½®ï¼Œè¯·åœ¨.env.localä¸­è®¾ç½®VITE_CONTRACT_ADDRESS')
        toast({
          title: 'é…ç½®è­¦å‘Š',
          description: 'æ™ºèƒ½åˆçº¦åœ°å€æœªé…ç½®ï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½æ— æ³•ä½¿ç”¨',
          status: 'warning',
          duration: 5000,
          isClosable: true,
        })
      } else {
        // åˆ›å»ºåˆçº¦å®ä¾‹
        const carbonContract = new ethers.Contract(
          contractAddress,
          CarbonCreditSystemABI,
          userSigner
        )
        setContract(carbonContract)
        
        console.log('âœ… æ™ºèƒ½åˆçº¦å·²è¿æ¥:', contractAddress)
      }
    }
  } catch (error) {
    console.error('è¿æ¥é’±åŒ…å¤±è´¥:', error)
  } finally {
    setIsConnecting(false)
  }
}
```

### 1.3 æ·»åŠ åŸºç¡€é”™è¯¯å¤„ç†

#### åˆ›å»ºé”™è¯¯å¤„ç†å·¥å…·

```typescript
// src/utils/errorHandler.ts - æ–°å»ºæ–‡ä»¶

export interface BlockchainError {
  code: string
  message: string
  userMessage: string
}

export const parseBlockchainError = (error: any): BlockchainError => {
  // ç”¨æˆ·æ‹’ç»äº¤æ˜“
  if (error.code === 'ACTION_REJECTED' || error.code === 4001) {
    return {
      code: 'USER_REJECTED',
      message: error.message,
      userMessage: 'ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“'
    }
  }
  
  // ä½™é¢ä¸è¶³
  if (error.code === 'INSUFFICIENT_FUNDS' || error.message?.includes('insufficient funds')) {
    return {
      code: 'INSUFFICIENT_FUNDS',
      message: error.message,
      userMessage: 'ETHä½™é¢ä¸è¶³ï¼Œæ— æ³•æ”¯ä»˜Gasè´¹ç”¨'
    }
  }
  
  // åˆçº¦æ‰§è¡Œå¤±è´¥
  if (error.message?.includes('execution reverted')) {
    let userMessage = 'æ™ºèƒ½åˆçº¦æ‰§è¡Œå¤±è´¥'
    
    // è§£æå…·ä½“çš„revertåŸå› 
    if (error.message.includes('insufficient balance')) {
      userMessage = 'ç¢³ä¿¡ç”¨ä½™é¢ä¸è¶³'
    } else if (error.message.includes('listing not active')) {
      userMessage = 'è¯¥ç¢³ä¿¡ç”¨å·²è¢«è´­ä¹°'
    } else if (error.message.includes('invalid amount')) {
      userMessage = 'è¾“å…¥é‡‘é¢æ— æ•ˆ'
    }
    
    return {
      code: 'CONTRACT_REVERT',
      message: error.message,
      userMessage
    }
  }
  
  // ç½‘ç»œé”™è¯¯
  if (error.code === 'NETWORK_ERROR') {
    return {
      code: 'NETWORK_ERROR',
      message: error.message,
      userMessage: 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®'
    }
  }
  
  // é»˜è®¤é”™è¯¯
  return {
    code: 'UNKNOWN_ERROR',
    message: error.message || 'æœªçŸ¥é”™è¯¯',
    userMessage: 'æ“ä½œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'
  }
}

// é€šç”¨çš„äº¤æ˜“æ‰§è¡Œå‡½æ•°
export const executeTransaction = async (
  transactionFunction: () => Promise<any>,
  description: string,
  onSuccess?: (receipt: any) => void,
  onError?: (error: BlockchainError) => void
) => {
  try {
    console.log(`ğŸš€ å¼€å§‹æ‰§è¡Œ: ${description}`)
    
    // æ‰§è¡Œäº¤æ˜“
    const tx = await transactionFunction()
    console.log(`ğŸ“¤ äº¤æ˜“å·²å‘é€: ${tx.hash}`)
    
    // ç­‰å¾…ç¡®è®¤
    const receipt = await tx.wait()
    
    if (receipt.status === 1) {
      console.log(`âœ… äº¤æ˜“æˆåŠŸ: ${description}`, {
        hash: receipt.hash,
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed.toString()
      })
      
      onSuccess?.(receipt)
      return receipt
    } else {
      throw new Error('äº¤æ˜“å¤±è´¥')
    }
    
  } catch (error) {
    const parsedError = parseBlockchainError(error)
    console.error(`âŒ äº¤æ˜“å¤±è´¥: ${description}`, parsedError)
    
    onError?.(parsedError)
    throw parsedError
  }
}
```

## 2. ä¸­æœŸæ”¹è¿›æ–¹æ¡ˆï¼ˆ1-2ä¸ªæœˆå†…å®Œæˆï¼‰

### 2.1 å®ç°äº‹ä»¶ç›‘å¬æœºåˆ¶

#### åˆ›å»ºäº‹ä»¶ç›‘å¬æœåŠ¡

```typescript
// src/services/eventListenerService.ts - æ–°å»ºæ–‡ä»¶

import { ethers } from 'ethers'
import { toast } from '@chakra-ui/react'

export class EventListenerService {
  private contract: ethers.Contract
  private account: string
  private listeners: { [key: string]: (...args: any[]) => void } = {}

  constructor(contract: ethers.Contract, account: string) {
    this.contract = contract
    this.account = account
  }

  // å¯åŠ¨æ‰€æœ‰äº‹ä»¶ç›‘å¬
  startListening() {
    this.listenToEmissionEvents()
    this.listenToTradingEvents()
    this.listenToListingEvents()
  }

  // ç›‘å¬æ’æ”¾è®°å½•äº‹ä»¶
  private listenToEmissionEvents() {
    const emissionFilter = this.contract.filters.EmissionRecorded(this.account)
    
    this.listeners.emission = (user: string, amount: bigint, activity: string, event: any) => {
      console.log('ğŸŒ± æ–°çš„æ’æ”¾è®°å½•:', {
        user,
        amount: ethers.formatEther(amount),
        activity,
        transactionHash: event.transactionHash
      })
      
      toast({
        title: 'æ’æ”¾è®°å½•å·²ç¡®è®¤',
        description: `${activity}: ${ethers.formatEther(amount)} å¨`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
      
      // è§¦å‘æ•°æ®åˆ·æ–°
      this.onEmissionRecorded?.({
        amount: parseFloat(ethers.formatEther(amount)),
        activity,
        timestamp: Date.now(),
        transactionHash: event.transactionHash
      })
    }
    
    this.contract.on(emissionFilter, this.listeners.emission)
  }

  // ç›‘å¬äº¤æ˜“äº‹ä»¶
  private listenToTradingEvents() {
    // ç›‘å¬è´­ä¹°äº‹ä»¶ï¼ˆä½œä¸ºä¹°å®¶ï¼‰
    const buyFilter = this.contract.filters.CreditPurchased(this.account, null, null, null)
    
    this.listeners.buy = (buyer: string, seller: string, amount: bigint, price: bigint, event: any) => {
      console.log('ğŸ’° è´­ä¹°æˆåŠŸ:', {
        buyer,
        seller,
        amount: ethers.formatEther(amount),
        price: ethers.formatEther(price),
        transactionHash: event.transactionHash
      })
      
      toast({
        title: 'è´­ä¹°æˆåŠŸ',
        description: `å·²è´­ä¹° ${ethers.formatEther(amount)} ä¸ªç¢³ä¿¡ç”¨`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
      
      this.onCreditPurchased?.({
        type: 'buy',
        amount: parseFloat(ethers.formatEther(amount)),
        price: parseFloat(ethers.formatEther(price)),
        counterparty: seller,
        transactionHash: event.transactionHash
      })
    }
    
    // ç›‘å¬é”€å”®äº‹ä»¶ï¼ˆä½œä¸ºå–å®¶ï¼‰
    const sellFilter = this.contract.filters.CreditPurchased(null, this.account, null, null)
    
    this.listeners.sell = (buyer: string, seller: string, amount: bigint, price: bigint, event: any) => {
      console.log('ğŸ’¸ é”€å”®æˆåŠŸ:', {
        buyer,
        seller,
        amount: ethers.formatEther(amount),
        price: ethers.formatEther(price),
        transactionHash: event.transactionHash
      })
      
      toast({
        title: 'é”€å”®æˆåŠŸ',
        description: `å·²å”®å‡º ${ethers.formatEther(amount)} ä¸ªç¢³ä¿¡ç”¨`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      })
      
      this.onCreditSold?.({
        type: 'sell',
        amount: parseFloat(ethers.formatEther(amount)),
        price: parseFloat(ethers.formatEther(price)),
        counterparty: buyer,
        transactionHash: event.transactionHash
      })
    }
    
    this.contract.on(buyFilter, this.listeners.buy)
    this.contract.on(sellFilter, this.listeners.sell)
  }

  // ç›‘å¬ä¸Šæ¶äº‹ä»¶
  private listenToListingEvents() {
    const listingFilter = this.contract.filters.CreditListed(null, null, null)
    
    this.listeners.listing = (seller: string, amount: bigint, price: bigint, event: any) => {
      console.log('ğŸ“‹ æ–°çš„ä¸Šæ¶:', {
        seller,
        amount: ethers.formatEther(amount),
        price: ethers.formatEther(price),
        transactionHash: event.transactionHash
      })
      
      // å¦‚æœä¸æ˜¯è‡ªå·±çš„ä¸Šæ¶ï¼Œæ˜¾ç¤ºé€šçŸ¥
      if (seller.toLowerCase() !== this.account.toLowerCase()) {
        toast({
          title: 'æ–°çš„ç¢³ä¿¡ç”¨ä¸Šæ¶',
          description: `${ethers.formatEther(amount)} ä¸ªç¢³ä¿¡ç”¨ï¼Œå•ä»· ${ethers.formatEther(price)} ETH`,
          status: 'info',
          duration: 3000,
          isClosable: true,
        })
      }
      
      this.onCreditListed?.({
        seller,
        amount: parseFloat(ethers.formatEther(amount)),
        price: parseFloat(ethers.formatEther(price)),
        transactionHash: event.transactionHash
      })
    }
    
    this.contract.on(listingFilter, this.listeners.listing)
  }

  // åœæ­¢æ‰€æœ‰ç›‘å¬
  stopListening() {
    Object.keys(this.listeners).forEach(key => {
      this.contract.removeAllListeners()
    })
    this.listeners = {}
  }

  // å›è°ƒå‡½æ•°æ¥å£
  onEmissionRecorded?: (data: any) => void
  onCreditPurchased?: (data: any) => void
  onCreditSold?: (data: any) => void
  onCreditListed?: (data: any) => void
}
```

#### åœ¨Web3Contextä¸­é›†æˆäº‹ä»¶ç›‘å¬

```typescript
// src/contexts/Web3Context.tsx - æ·»åŠ äº‹ä»¶ç›‘å¬

import { EventListenerService } from '../services/eventListenerService'

export const Web3Provider = ({ children }: Web3ProviderProps) => {
  // ... ç°æœ‰çŠ¶æ€
  const [eventListener, setEventListener] = useState<EventListenerService | null>(null)

  // å½“åˆçº¦å’Œè´¦æˆ·éƒ½å¯ç”¨æ—¶ï¼Œå¯åŠ¨äº‹ä»¶ç›‘å¬
  useEffect(() => {
    if (contract && account) {
      const listener = new EventListenerService(contract, account)
      
      // è®¾ç½®å›è°ƒå‡½æ•°
      listener.onEmissionRecorded = (data) => {
        console.log('æ’æ”¾è®°å½•äº‹ä»¶å›è°ƒ:', data)
        // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘å…¨å±€çŠ¶æ€æ›´æ–°
      }
      
      listener.onCreditPurchased = (data) => {
        console.log('è´­ä¹°äº‹ä»¶å›è°ƒ:', data)
        // æ›´æ–°ç”¨æˆ·ä½™é¢ç­‰
      }
      
      listener.onCreditSold = (data) => {
        console.log('é”€å”®äº‹ä»¶å›è°ƒ:', data)
        // æ›´æ–°ç”¨æˆ·ä½™é¢ç­‰
      }
      
      listener.onCreditListed = (data) => {
        console.log('ä¸Šæ¶äº‹ä»¶å›è°ƒ:', data)
        // åˆ·æ–°å¸‚åœºæ•°æ®
      }
      
      listener.startListening()
      setEventListener(listener)
      
      return () => {
        listener.stopListening()
      }
    }
  }, [contract, account])

  // æ–­å¼€è¿æ¥æ—¶åœæ­¢ç›‘å¬
  const disconnectWallet = () => {
    if (eventListener) {
      eventListener.stopListening()
      setEventListener(null)
    }
    
    setAccount(null)
    setChainId(null)
    setProvider(null)
    setSigner(null)
    setContract(null)
  }

  // ... å…¶ä½™ä»£ç 
}
```

### 2.2 å®ç°å®Œæ•´çš„æ•°æ®åŒæ­¥æœºåˆ¶

#### åˆ›å»ºåŒºå—é“¾æ•°æ®åŒæ­¥æœåŠ¡

```typescript
// src/services/blockchainSyncService.ts - æ–°å»ºæ–‡ä»¶

import { ethers } from 'ethers'
import { getUserData, saveUserData, UserData } from './userDataService'

export class BlockchainSyncService {
  private contract: ethers.Contract
  private account: string
  private syncInterval: NodeJS.Timeout | null = null

  constructor(contract: ethers.Contract, account: string) {
    this.contract = contract
    this.account = account
  }

  // å¯åŠ¨å®šæœŸåŒæ­¥
  startPeriodicSync(intervalMs: number = 30000) { // é»˜è®¤30ç§’åŒæ­¥ä¸€æ¬¡
    this.syncInterval = setInterval(() => {
      this.syncAllData()
    }, intervalMs)
    
    // ç«‹å³æ‰§è¡Œä¸€æ¬¡åŒæ­¥
    this.syncAllData()
  }

  // åœæ­¢å®šæœŸåŒæ­¥
  stopPeriodicSync() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval)
      this.syncInterval = null
    }
  }

  // åŒæ­¥æ‰€æœ‰æ•°æ®
  async syncAllData() {
    try {
      console.log('ğŸ”„ å¼€å§‹åŒæ­¥åŒºå—é“¾æ•°æ®...')
      
      const [carbonCredits, totalEmissions, transactions] = await Promise.all([
        this.syncCarbonCredits(),
        this.syncTotalEmissions(),
        this.syncTransactionHistory()
      ])

      // æ›´æ–°æœ¬åœ°å­˜å‚¨
      const userData: UserData = {
        carbonCredits,
        totalEmissions,
        transactions
      }
      
      saveUserData(this.account, userData)
      console.log('âœ… æ•°æ®åŒæ­¥å®Œæˆ:', userData)
      
      return userData
    } catch (error) {
      console.error('âŒ æ•°æ®åŒæ­¥å¤±è´¥:', error)
      throw error
    }
  }

  // åŒæ­¥ç¢³ä¿¡ç”¨ä½™é¢
  private async syncCarbonCredits(): Promise<number> {
    try {
      const balance = await this.contract.balanceOf(this.account)
      return parseFloat(ethers.formatEther(balance))
    } catch (error) {
      console.error('åŒæ­¥ç¢³ä¿¡ç”¨ä½™é¢å¤±è´¥:', error)
      return 0
    }
  }

  // åŒæ­¥æ€»æ’æ”¾é‡
  private async syncTotalEmissions(): Promise<number> {
    try {
      const emissions = await this.contract.getUserEmissions()
      return emissions.reduce((total: number, emission: any) => {
        return total + parseFloat(ethers.formatEther(emission.amount))
      }, 0)
    } catch (error) {
      console.error('åŒæ­¥æ€»æ’æ”¾é‡å¤±è´¥:', error)
      return 0
    }
  }

  // åŒæ­¥äº¤æ˜“å†å²
  private async syncTransactionHistory(): Promise<any[]> {
    try {
      const transactions: any[] = []
      
      // è·å–è´­ä¹°äº‹ä»¶
      const purchaseFilter = this.contract.filters.CreditPurchased(this.account, null, null, null)
      const purchaseEvents = await this.contract.queryFilter(purchaseFilter, -10000) // æŸ¥è¯¢æœ€è¿‘10000ä¸ªåŒºå—
      
      for (const event of purchaseEvents) {
        const block = await event.getBlock()
        transactions.push({
          id: event.transactionHash,
          type: 'buy',
          amount: parseFloat(ethers.formatEther(event.args.amount)),
          price: parseFloat(ethers.formatEther(event.args.price)),
          date: new Date(block.timestamp * 1000).toISOString(),
          counterparty: event.args.seller,
          txHash: event.transactionHash,
          status: 'confirmed',
          blockNumber: event.blockNumber
        })
      }
      
      // è·å–é”€å”®äº‹ä»¶
      const saleFilter = this.contract.filters.CreditPurchased(null, this.account, null, null)
      const saleEvents = await this.contract.queryFilter(saleFilter, -10000)
      
      for (const event of saleEvents) {
        const block = await event.getBlock()
        transactions.push({
          id: event.transactionHash,
          type: 'sell',
          amount: parseFloat(ethers.formatEther(event.args.amount)),
          price: parseFloat(ethers.formatEther(event.args.price)),
          date: new Date(block.timestamp * 1000).toISOString(),
          counterparty: event.args.buyer,
          txHash: event.transactionHash,
          status: 'confirmed',
          blockNumber: event.blockNumber
        })
      }
      
      // æŒ‰æ—¶é—´æ’åº
      return transactions.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
      
    } catch (error) {
      console.error('åŒæ­¥äº¤æ˜“å†å²å¤±è´¥:', error)
      return []
    }
  }

  // æ‰‹åŠ¨è§¦å‘åŒæ­¥
  async forcSync() {
    return this.syncAllData()
  }
}
```

### 2.3 ä¼˜åŒ–ç”¨æˆ·ä½“éªŒ

#### æ·»åŠ åŠ è½½çŠ¶æ€å’Œè¿›åº¦æŒ‡ç¤º

```typescript
// src/components/LoadingStates.tsx - æ–°å»ºæ–‡ä»¶

import React from 'react'
import {
  Box,
  Spinner,
  Text,
  Progress,
  VStack,
  HStack,
  Icon
} from '@chakra-ui/react'
import { CheckCircleIcon, WarningIcon } from '@chakra-ui/icons'

interface TransactionStatusProps {
  status: 'idle' | 'sending' | 'pending' | 'confirmed' | 'failed'
  txHash?: string
  description?: string
}

export const TransactionStatus: React.FC<TransactionStatusProps> = ({
  status,
  txHash,
  description
}) => {
  const getStatusConfig = () => {
    switch (status) {
      case 'sending':
        return {
          color: 'blue.500',
          icon: <Spinner size="sm" />,
          text: 'å‘é€äº¤æ˜“ä¸­...',
          progress: 25
        }
      case 'pending':
        return {
          color: 'yellow.500',
          icon: <Spinner size="sm" />,
          text: 'ç­‰å¾…åŒºå—ç¡®è®¤...',
          progress: 75
        }
      case 'confirmed':
        return {
          color: 'green.500',
          icon: <CheckCircleIcon />,
          text: 'äº¤æ˜“å·²ç¡®è®¤',
          progress: 100
        }
      case 'failed':
        return {
          color: 'red.500',
          icon: <WarningIcon />,
          text: 'äº¤æ˜“å¤±è´¥',
          progress: 0
        }
      default:
        return null
    }
  }

  const config = getStatusConfig()
  if (!config) return null

  return (
    <Box p={4} borderWidth={1} borderRadius="md" bg="gray.50">
      <VStack spacing={3} align="stretch">
        <HStack>
          <Icon as={() => config.icon} color={config.color} />
          <Text fontWeight="medium" color={config.color}>
            {config.text}
          </Text>
        </HStack>
        
        {description && (
          <Text fontSize="sm" color="gray.600">
            {description}
          </Text>
        )}
        
        <Progress value={config.progress} colorScheme={config.color.split('.')[0]} size="sm" />
        
        {txHash && (
          <Text fontSize="xs" color="gray.500" fontFamily="mono">
            äº¤æ˜“å“ˆå¸Œ: {txHash.substring(0, 10)}...{txHash.substring(txHash.length - 8)}
          </Text>
        )}
      </VStack>
    </Box>
  )
}

// æ•°æ®åŒæ­¥çŠ¶æ€ç»„ä»¶
interface SyncStatusProps {
  isSync: boolean
  lastSyncTime?: Date
  onForceSync?: () => void
}

export const SyncStatus: React.FC<SyncStatusProps> = ({
  isSync,
  lastSyncTime,
  onForceSync
}) => {
  return (
    <HStack spacing={2} fontSize="sm" color="gray.600">
      {isSync ? (
        <>
          <Spinner size="xs" />
          <Text>åŒæ­¥ä¸­...</Text>
        </>
      ) : (
        <>
          <CheckCircleIcon color="green.500" />
          <Text>
            å·²åŒæ­¥ {lastSyncTime ? `(${lastSyncTime.toLocaleTimeString()})` : ''}
          </Text>
          {onForceSync && (
            <Text
              as="button"
              color="blue.500"
              textDecoration="underline"
              onClick={onForceSync}
            >
              æ‰‹åŠ¨åŒæ­¥
            </Text>
          )}
        </>
      )}
    </HStack>
  )
}
```

## 3. é•¿æœŸæ”¹è¿›æ–¹æ¡ˆï¼ˆ3-6ä¸ªæœˆå†…å®Œæˆï¼‰

### 3.1 æ™ºèƒ½åˆçº¦å®‰å…¨æ€§å¢å¼º

#### å®‰å…¨åˆçº¦æ¨¡æ¿

```solidity
// contracts/CarbonCreditSystemV2.sol - å®‰å…¨å¢å¼ºç‰ˆæœ¬

pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract CarbonCreditSystemV2 is ReentrancyGuard, Pausable, Ownable {
    using SafeMath for uint256;

    // äº‹ä»¶å®šä¹‰
    event EmissionRecorded(address indexed user, uint256 amount, string activity, uint256 timestamp);
    event CreditMinted(address indexed to, uint256 amount, string reason);
    event CreditPurchased(address indexed buyer, address indexed seller, uint256 amount, uint256 price);
    event CreditListed(address indexed seller, uint256 listingId, uint256 amount, uint256 price);
    event ListingCancelled(address indexed seller, uint256 listingId);

    // æ•°æ®ç»“æ„
    struct EmissionRecord {
        uint256 amount;
        uint256 timestamp;
        string activity;
        bool verified;  // æ˜¯å¦å·²éªŒè¯
    }

    struct CreditListing {
        address seller;
        uint256 amount;
        uint256 price;
        bool active;
        uint256 createdAt;
        uint256 expiresAt;  // è¿‡æœŸæ—¶é—´
    }

    // çŠ¶æ€å˜é‡
    mapping(address => uint256) public carbonCredits;
    mapping(address => EmissionRecord[]) public userEmissions;
    mapping(address => bool) public verifiers;  // éªŒè¯è€…æƒé™
    CreditListing[] public listings;
    
    // é…ç½®å‚æ•°
    uint256 public constant MAX_LISTING_DURATION = 30 days;
    uint256 public constant MIN_CREDIT_AMOUNT = 1e15;  // 0.001 ETH worth
    uint256 public tradingFeeRate = 250;  // 2.5% (basis points)
    address public feeRecipient;

    constructor() {
        feeRecipient = msg.sender;
    }

    // ä¿®é¥°ç¬¦
    modifier onlyVerifier() {
        require(verifiers[msg.sender] || msg.sender == owner(), "Not authorized verifier");
        _;
    }

    modifier validAmount(uint256 amount) {
        require(amount >= MIN_CREDIT_AMOUNT, "Amount too small");
        _;
    }

    // ç®¡ç†åŠŸèƒ½
    function addVerifier(address verifier) external onlyOwner {
        verifiers[verifier] = true;
    }

    function removeVerifier(address verifier) external onlyOwner {
        verifiers[verifier] = false;
    }

    function setTradingFeeRate(uint256 newRate) external onlyOwner {
        require(newRate <= 1000, "Fee rate too high");  // æœ€å¤§10%
        tradingFeeRate = newRate;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    // æ ¸å¿ƒåŠŸèƒ½
    function recordEmission(uint256 amount, string memory activity) 
        external 
        whenNotPaused 
        validAmount(amount) 
    {
        EmissionRecord memory newRecord = EmissionRecord({
            amount: amount,
            timestamp: block.timestamp,
            activity: activity,
            verified: false
        });
        
        userEmissions[msg.sender].push(newRecord);
        
        emit EmissionRecorded(msg.sender, amount, activity, block.timestamp);
    }

    function verifyEmission(address user, uint256 recordIndex) 
        external 
        onlyVerifier 
    {
        require(recordIndex < userEmissions[user].length, "Invalid record index");
        userEmissions[user][recordIndex].verified = true;
    }

    function mintCredits(address to, uint256 amount, string memory reason) 
        external 
        onlyVerifier 
        validAmount(amount) 
    {
        carbonCredits[to] = carbonCredits[to].add(amount);
        emit CreditMinted(to, amount, reason);
    }

    function listCredit(uint256 amount, uint256 price) 
        external 
        whenNotPaused 
        validAmount(amount) 
        nonReentrant 
    {
        require(carbonCredits[msg.sender] >= amount, "Insufficient credits");
        require(price > 0, "Invalid price");
        
        // å†»ç»“ç¢³ä¿¡ç”¨
        carbonCredits[msg.sender] = carbonCredits[msg.sender].sub(amount);
        
        uint256 listingId = listings.length;
        listings.push(CreditListing({
            seller: msg.sender,
            amount: amount,
            price: price,
            active: true,
            createdAt: block.timestamp,
            expiresAt: block.timestamp.add(MAX_LISTING_DURATION)
        }));
        
        emit CreditListed(msg.sender, listingId, amount, price);
    }

    function buyCredit(uint256 listingId) 
        external 
        payable 
        whenNotPaused 
        nonReentrant 
    {
        require(listingId < listings.length, "Invalid listing");
        
        CreditListing storage listing = listings[listingId];
        require(listing.active, "Listing not active");
        require(block.timestamp <= listing.expiresAt, "Listing expired");
        require(msg.sender != listing.seller, "Cannot buy own listing");
        
        uint256 totalPrice = listing.amount.mul(listing.price);
        require(msg.value >= totalPrice, "Insufficient payment");
        
        // è®¡ç®—æ‰‹ç»­è´¹
        uint256 fee = totalPrice.mul(tradingFeeRate).div(10000);
        uint256 sellerAmount = totalPrice.sub(fee);
        
        // æ›´æ–°çŠ¶æ€
        listing.active = false;
        carbonCredits[msg.sender] = carbonCredits[msg.sender].add(listing.amount);
        
        // è½¬è´¦
        (bool success1, ) = payable(listing.seller).call{value: sellerAmount}("");
        require(success1, "Transfer to seller failed");
        
        (bool success2, ) = payable(feeRecipient).call{value: fee}("");
        require(success2, "Fee transfer failed");
        
        // é€€è¿˜å¤šä½™é‡‘é¢
        if (msg.value > totalPrice) {
            (bool success3, ) = payable(msg.sender).call{value: msg.value.sub(totalPrice)}("");
            require(success3, "Refund failed");
        }
        
        emit CreditPurchased(msg.sender, listing.seller, listing.amount, totalPrice);
    }

    function cancelListing(uint256 listingId) 
        external 
        nonReentrant 
    {
        require(listingId < listings.length, "Invalid listing");
        
        CreditListing storage listing = listings[listingId];
        require(listing.seller == msg.sender, "Not listing owner");
        require(listing.active, "Listing not active");
        
        // é€€è¿˜ç¢³ä¿¡ç”¨
        listing.active = false;
        carbonCredits[msg.sender] = carbonCredits[msg.sender].add(listing.amount);
        
        emit ListingCancelled(msg.sender, listingId);
    }

    // æŸ¥è¯¢åŠŸèƒ½
    function getUserEmissions() external view returns (EmissionRecord[] memory) {
        return userEmissions[msg.sender];
    }

    function getActiveListings() external view returns (CreditListing[] memory) {
        uint256 activeCount = 0;
        
        // è®¡ç®—æ´»è·ƒä¸Šæ¶æ•°é‡
        for (uint256 i = 0; i < listings.length; i++) {
            if (listings[i].active && block.timestamp <= listings[i].expiresAt) {
                activeCount++;
            }
        }
        
        // åˆ›å»ºæ´»è·ƒä¸Šæ¶æ•°ç»„
        CreditListing[] memory activeListings = new CreditListing[](activeCount);
        uint256 index = 0;
        
        for (uint256 i = 0; i < listings.length; i++) {
            if (listings[i].active && block.timestamp <= listings[i].expiresAt) {
                activeListings[index] = listings[i];
                index++;
            }
        }
        
        return activeListings;
    }

    function balanceOf(address account) external view returns (uint256) {
        return carbonCredits[account];
    }

    // ç´§æ€¥åŠŸèƒ½
    function emergencyWithdraw() external onlyOwner {
        (bool success, ) = payable(owner()).call{value: address(this).balance}("");
        require(success, "Emergency withdraw failed");
    }
}
```

### 3.2 å¤šé“¾æ”¯æŒ

#### è·¨é“¾æ¡¥æ¥åˆçº¦

```solidity
// contracts/CarbonCreditBridge.sol

pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract CarbonCreditBridge is ReentrancyGuard, Ownable {
    // è·¨é“¾è½¬ç§»äº‹ä»¶
    event CrossChainTransferInitiated(
        address indexed from,
        uint256 amount,
        uint256 targetChainId,
        bytes32 transferId
    );
    
    event CrossChainTransferCompleted(
        address indexed to,
        uint256 amount,
        uint256 sourceChainId,
        bytes32 transferId
    );
    
    // æ”¯æŒçš„é“¾
    mapping(uint256 => bool) public supportedChains;
    mapping(bytes32 => bool) public processedTransfers;
    
    // éªŒè¯è€…
    mapping(address => bool) public validators;
    uint256 public requiredValidations = 2;
    
    struct CrossChainTransfer {
        address from;
        address to;
        uint256 amount;
        uint256 sourceChainId;
        uint256 targetChainId;
        uint256 validations;
        bool completed;
    }
    
    mapping(bytes32 => CrossChainTransfer) public transfers;
    mapping(bytes32 => mapping(address => bool)) public transferValidations;
    
    // ä¸»åˆçº¦æ¥å£
    interface ICarbonCreditSystem {
        function burnCredits(address from, uint256 amount) external;
        function mintCredits(address to, uint256 amount, string memory reason) external;
    }
    
    ICarbonCreditSystem public carbonContract;
    
    constructor(address _carbonContract) {
        carbonContract = ICarbonCreditSystem(_carbonContract);
    }
    
    // å‘èµ·è·¨é“¾è½¬ç§»
    function initiateCrossChainTransfer(
        uint256 amount,
        uint256 targetChainId,
        address targetAddress
    ) external nonReentrant {
        require(supportedChains[targetChainId], "Target chain not supported");
        require(amount > 0, "Invalid amount");
        
        bytes32 transferId = keccak256(abi.encodePacked(
            msg.sender,
            targetAddress,
            amount,
            block.chainid,
            targetChainId,
            block.timestamp
        ));
        
        // é”€æ¯æºé“¾ä¸Šçš„ç¢³ä¿¡ç”¨
        carbonContract.burnCredits(msg.sender, amount);
        
        transfers[transferId] = CrossChainTransfer({
            from: msg.sender,
            to: targetAddress,
            amount: amount,
            sourceChainId: block.chainid,
            targetChainId: targetChainId,
            validations: 0,
            completed: false
        });
        
        emit CrossChainTransferInitiated(msg.sender, amount, targetChainId, transferId);
    }
    
    // éªŒè¯è·¨é“¾è½¬ç§»
    function validateTransfer(bytes32 transferId) external {
        require(validators[msg.sender], "Not a validator");
        require(!transferValidations[transferId][msg.sender], "Already validated");
        require(!transfers[transferId].completed, "Transfer already completed");
        
        transferValidations[transferId][msg.sender] = true;
        transfers[transferId].validations++;
        
        // å¦‚æœè¾¾åˆ°æ‰€éœ€éªŒè¯æ•°é‡ï¼Œå®Œæˆè½¬ç§»
        if (transfers[transferId].validations >= requiredValidations) {
            completeTransfer(transferId);
        }
    }
    
    // å®Œæˆè·¨é“¾è½¬ç§»
    function completeTransfer(bytes32 transferId) internal {
        CrossChainTransfer storage transfer = transfers[transferId];
        require(!transfer.completed, "Transfer already completed");
        
        transfer.completed = true;
        
        // åœ¨ç›®æ ‡é“¾ä¸Šé“¸é€ ç¢³ä¿¡ç”¨
        carbonContract.mintCredits(
            transfer.to,
            transfer.amount,
            "Cross-chain transfer"
        );
        
        emit CrossChainTransferCompleted(
            transfer.to,
            transfer.amount,
            transfer.sourceChainId,
            transferId
        );
    }
}
```

### 3.3 é«˜çº§DeFiåŠŸèƒ½é›†æˆ

#### ç¢³ä¿¡ç”¨è´¨æŠ¼å’ŒæµåŠ¨æ€§æŒ–çŸ¿

```solidity
// contracts/CarbonCreditStaking.sol

pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract CarbonCreditStaking is ReentrancyGuard {
    using SafeMath for uint256;
    
    IERC20 public carbonToken;  // ç¢³ä¿¡ç”¨ä»£å¸
    IERC20 public rewardToken;  // å¥–åŠ±ä»£å¸
    
    struct StakeInfo {
        uint256 amount;
        uint256 rewardDebt;
        uint256 stakingTime;
    }
    
    mapping(address => StakeInfo) public stakes;
    
    uint256 public totalStaked;
    uint256 public rewardPerSecond;
    uint256 public accRewardPerShare;
    uint256 public lastRewardTime;
    
    event Staked(address indexed user, uint256 amount);
    event Unstaked(address indexed user, uint256 amount);
    event RewardClaimed(address indexed user, uint256 amount);
    
    constructor(
        address _carbonToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) {
        carbonToken = IERC20(_carbonToken);
        rewardToken = IERC20(_rewardToken);
        rewardPerSecond = _rewardPerSecond;
        lastRewardTime = block.timestamp;
    }
    
    // è´¨æŠ¼ç¢³ä¿¡ç”¨
    function stake(uint256 amount) external nonReentrant {
        require(amount > 0, "Cannot stake 0");
        
        updatePool();
        
        StakeInfo storage userStake = stakes[msg.sender];
        
        // å¦‚æœç”¨æˆ·å·²æœ‰è´¨æŠ¼ï¼Œå…ˆé¢†å–å¥–åŠ±
        if (userStake.amount > 0) {
            uint256 pending = userStake.amount.mul(accRewardPerShare).div(1e12).sub(userStake.rewardDebt);
            if (pending > 0) {
                rewardToken.transfer(msg.sender, pending);
                emit RewardClaimed(msg.sender, pending);
            }
        }
        
        // è½¬ç§»ç¢³ä¿¡ç”¨åˆ°åˆçº¦
        carbonToken.transferFrom(msg.sender, address(this), amount);
        
        // æ›´æ–°è´¨æŠ¼ä¿¡æ¯
        userStake.amount = userStake.amount.add(amount);
        userStake.stakingTime = block.timestamp;
        userStake.rewardDebt = userStake.amount.mul(accRewardPerShare).div(1e12);
        
        totalStaked = totalStaked.add(amount);
        
        emit Staked(msg.sender, amount);
    }
    
    // å–æ¶ˆè´¨æŠ¼
    function unstake(uint256 amount) external nonReentrant {
        StakeInfo storage userStake = stakes[msg.sender];
        require(userStake.amount >= amount, "Insufficient staked amount");
        
        updatePool();
        
        // è®¡ç®—å¹¶å‘æ”¾å¥–åŠ±
        uint256 pending = userStake.amount.mul(accRewardPerShare).div(1e12).sub(userStake.rewardDebt);
        if (pending > 0) {
            rewardToken.transfer(msg.sender, pending);
            emit RewardClaimed(msg.sender, pending);
        }
        
        // æ›´æ–°è´¨æŠ¼ä¿¡æ¯
        userStake.amount = userStake.amount.sub(amount);
        userStake.rewardDebt = userStake.amount.mul(accRewardPerShare).div(1e12);
        
        totalStaked = totalStaked.sub(amount);
        
        // è¿”è¿˜ç¢³ä¿¡ç”¨
        carbonToken.transfer(msg.sender, amount);
        
        emit Unstaked(msg.sender, amount);
    }
    
    // é¢†å–å¥–åŠ±
    function claimReward() external nonReentrant {
        updatePool();
        
        StakeInfo storage userStake = stakes[msg.sender];
        uint256 pending = userStake.amount.mul(accRewardPerShare).div(1e12).sub(userStake.rewardDebt);
        
        require(pending > 0, "No pending rewards");
        
        userStake.rewardDebt = userStake.amount.mul(accRewardPerShare).div(1e12);
        rewardToken.transfer(msg.sender, pending);
        
        emit RewardClaimed(msg.sender, pending);
    }
    
    // æ›´æ–°å¥–åŠ±æ± 
    function updatePool() public {
        if (block.timestamp <= lastRewardTime) {
            return;
        }
        
        if (totalStaked == 0) {
            lastRewardTime = block.timestamp;
            return;
        }
        
        uint256 timeElapsed = block.timestamp.sub(lastRewardTime);
        uint256 reward = timeElapsed.mul(rewardPerSecond);
        accRewardPerShare = accRewardPerShare.add(reward.mul(1e12).div(totalStaked));
        lastRewardTime = block.timestamp;
    }
    
    // æŸ¥è¯¢å¾…é¢†å–å¥–åŠ±
    function pendingReward(address user) external view returns (uint256) {
        StakeInfo storage userStake = stakes[user];
        uint256 tempAccRewardPerShare = accRewardPerShare;
        
        if (block.timestamp > lastRewardTime && totalStaked != 0) {
            uint256 timeElapsed = block.timestamp.sub(lastRewardTime);
            uint256 reward = timeElapsed.mul(rewardPerSecond);
            tempAccRewardPerShare = tempAccRewardPerShare.add(reward.mul(1e12).div(totalStaked));
        }
        
        return userStake.amount.mul(tempAccRewardPerShare).div(1e12).sub(userStake.rewardDebt);
    }
}
```

## 4. éƒ¨ç½²å’Œæµ‹è¯•æŒ‡å—

### 4.1 æµ‹è¯•ç½‘éƒ¨ç½²æ­¥éª¤

```bash
# 1. å®‰è£…ä¾èµ–
npm install --save-dev hardhat @nomiclabs/hardhat-ethers ethers

# 2. åˆ›å»ºHardhaté…ç½®
# hardhat.config.js
require("@nomiclabs/hardhat-ethers");

module.exports = {
  solidity: "0.8.19",
  networks: {
    sepolia: {
      url: "https://sepolia.infura.io/v3/YOUR_PROJECT_ID",
      accounts: ["YOUR_PRIVATE_KEY"]
    },
    localhost: {
      url: "http://127.0.0.1:8545"
    }
  }
};

# 3. åˆ›å»ºéƒ¨ç½²è„šæœ¬
# scripts/deploy.js
const { ethers } = require("hardhat");

async function main() {
  console.log("å¼€å§‹éƒ¨ç½²ç¢³ä¿¡ç”¨ç³»ç»Ÿåˆçº¦...");
  
  // éƒ¨ç½²ä¸»åˆçº¦
  const CarbonCreditSystem = await ethers.getContractFactory("CarbonCreditSystemV2");
  const carbonContract = await CarbonCreditSystem.deploy();
  await carbonContract.deployed();
  
  console.log("ç¢³ä¿¡ç”¨ç³»ç»Ÿåˆçº¦å·²éƒ¨ç½²åˆ°:", carbonContract.address);
  
  // éƒ¨ç½²è´¨æŠ¼åˆçº¦ï¼ˆå¦‚æœéœ€è¦ï¼‰
  const StakingContract = await ethers.getContractFactory("CarbonCreditStaking");
  const stakingContract = await StakingContract.deploy(
    carbonContract.address,  // ç¢³ä¿¡ç”¨ä»£å¸åœ°å€
    carbonContract.address,  // å¥–åŠ±ä»£å¸åœ°å€ï¼ˆæš‚æ—¶ä½¿ç”¨åŒä¸€ä¸ªï¼‰
    ethers.utils.parseEther("0.1")  // æ¯ç§’å¥–åŠ±æ•°é‡
  );
  await stakingContract.deployed();
  
  console.log("è´¨æŠ¼åˆçº¦å·²éƒ¨ç½²åˆ°:", stakingContract.address);
  
  // ä¿å­˜åˆçº¦åœ°å€
  const addresses = {
    carbonContract: carbonContract.address,
    stakingContract: stakingContract.address,
    network: "sepolia",
    deployTime: new Date().toISOString()
  };
  
  console.log("éƒ¨ç½²å®Œæˆ:", addresses);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

# 4. æ‰§è¡Œéƒ¨ç½²
npx hardhat run scripts/deploy.js --network sepolia
```

### 4.2 å‰ç«¯é›†æˆæµ‹è¯•

```typescript
// src/utils/contractTesting.ts - åˆçº¦æµ‹è¯•å·¥å…·

import { ethers } from 'ethers'
import CarbonCreditSystemABI from '../contracts/CarbonCreditSystem.json'

export class ContractTester {
  private contract: ethers.Contract
  private signer: ethers.Signer

  constructor(contractAddress: string, signer: ethers.Signer) {
    this.contract = new ethers.Contract(contractAddress, CarbonCreditSystemABI, signer)
    this.signer = signer
  }

  // æµ‹è¯•æ’æ”¾è®°å½•åŠŸèƒ½
  async testEmissionRecording() {
    console.log('ğŸ§ª æµ‹è¯•æ’æ”¾è®°å½•åŠŸèƒ½...')
    
    try {
      // è®°å½•æ’æ”¾
      const tx = await this.contract.recordEmission(
        ethers.parseEther('2.5'),
        'æµ‹è¯•æ’æ”¾æ´»åŠ¨'
      )
      const receipt = await tx.wait()
      console.log('âœ… æ’æ”¾è®°å½•æˆåŠŸ:', receipt.hash)
      
      // è·å–æ’æ”¾è®°å½•
      const emissions = await this.contract.getUserEmissions()
      console.log('ğŸ“Š ç”¨æˆ·æ’æ”¾è®°å½•:', emissions)
      
      return true
    } catch (error) {
      console.error('âŒ æ’æ”¾è®°å½•æµ‹è¯•å¤±è´¥:', error)
      return false
    }
  }

  // æµ‹è¯•ç¢³ä¿¡ç”¨äº¤æ˜“åŠŸèƒ½
  async testCreditTrading() {
    console.log('ğŸ§ª æµ‹è¯•ç¢³ä¿¡ç”¨äº¤æ˜“åŠŸèƒ½...')
    
    try {
      // é¦–å…ˆéœ€è¦æœ‰ç¢³ä¿¡ç”¨ä½™é¢ï¼ˆé€šè¿‡ç®¡ç†å‘˜é“¸é€ ï¼‰
      const balance = await this.contract.balanceOf(await this.signer.getAddress())
      console.log('ğŸ’° å½“å‰ç¢³ä¿¡ç”¨ä½™é¢:', ethers.formatEther(balance))
      
      if (balance.gt(0)) {
        // æµ‹è¯•ä¸Šæ¶
        const listTx = await this.contract.listCredit(
          ethers.parseEther('1'),
          ethers.parseEther('0.01')
        )
        await listTx.wait()
        console.log('âœ… ç¢³ä¿¡ç”¨ä¸Šæ¶æˆåŠŸ')
        
        // è·å–å¸‚åœºæ•°æ®
        const listings = await this.contract.getActiveListings()
        console.log('ğŸª å¸‚åœºä¸Šæ¶æ•°æ®:', listings)
      } else {
        console.log('âš ï¸ ä½™é¢ä¸è¶³ï¼Œè·³è¿‡äº¤æ˜“æµ‹è¯•')
      }
      
      return true
    } catch (error) {
      console.error('âŒ äº¤æ˜“æµ‹è¯•å¤±è´¥:', error)
      return false
    }
  }

  // æµ‹è¯•äº‹ä»¶ç›‘å¬
  async testEventListening() {
    console.log('ğŸ§ª æµ‹è¯•äº‹ä»¶ç›‘å¬åŠŸèƒ½...')
    
    return new Promise((resolve) => {
      let eventReceived = false
      
      // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
      this.contract.once('EmissionRecorded', (user, amount, activity) => {
        console.log('ğŸ“¡ æ¥æ”¶åˆ°æ’æ”¾è®°å½•äº‹ä»¶:', {
          user,
          amount: ethers.formatEther(amount),
          activity
        })
        eventReceived = true
        resolve(true)
      })
      
      // è§¦å‘äº‹ä»¶
      this.contract.recordEmission(
        ethers.parseEther('1'),
        'äº‹ä»¶æµ‹è¯•'
      ).then(tx => tx.wait())
      
      // è¶…æ—¶å¤„ç†
      setTimeout(() => {
        if (!eventReceived) {
          console.log('âš ï¸ äº‹ä»¶ç›‘å¬è¶…æ—¶')
          resolve(false)
        }
      }, 30000)
    })
  }

  // è¿è¡Œæ‰€æœ‰æµ‹è¯•
  async runAllTests() {
    console.log('ğŸš€ å¼€å§‹è¿è¡Œåˆçº¦é›†æˆæµ‹è¯•...')
    
    const results = {
      emission: await this.testEmissionRecording(),
      trading: await this.testCreditTrading(),
      events: await this.testEventListening()
    }
    
    console.log('ğŸ“‹ æµ‹è¯•ç»“æœæ±‡æ€»:', results)
    
    const allPassed = Object.values(results).every(result => result)
    console.log(allPassed ? 'ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡!' : 'âš ï¸ éƒ¨åˆ†æµ‹è¯•å¤±è´¥')
    
    return results
  }
}
```

### 4.3 æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–

```typescript
// src/utils/performanceMonitor.ts - æ€§èƒ½ç›‘æ§å·¥å…·

export class PerformanceMonitor {
  private metrics: { [key: string]: number[] } = {}
  private gasUsage: { [key: string]: number[] } = {}

  // è®°å½•äº¤æ˜“æ€§èƒ½
  recordTransaction(operation: string, gasUsed: number, duration: number) {
    if (!this.metrics[operation]) {
      this.metrics[operation] = []
      this.gasUsage[operation] = []
    }
    
    this.metrics[operation].push(duration)
    this.gasUsage[operation].push(gasUsed)
    
    console.log(`ğŸ“Š ${operation} æ€§èƒ½:`, {
      duration: `${duration}ms`,
      gasUsed: gasUsed.toLocaleString(),
      avgDuration: this.getAverageMetric(operation),
      avgGas: this.getAverageGas(operation)
    })
  }

  // è·å–å¹³å‡å“åº”æ—¶é—´
  getAverageMetric(operation: string): number {
    const metrics = this.metrics[operation]
    if (!metrics || metrics.length === 0) return 0
    return metrics.reduce((sum, val) => sum + val, 0) / metrics.length
  }

  // è·å–å¹³å‡Gasæ¶ˆè€—
  getAverageGas(operation: string): number {
    const gasUsage = this.gasUsage[operation]
    if (!gasUsage || gasUsage.length === 0) return 0
    return gasUsage.reduce((sum, val) => sum + val, 0) / gasUsage.length
  }

  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      operations: {} as any
    }
    
    Object.keys(this.metrics).forEach(operation => {
      report.operations[operation] = {
        totalCalls: this.metrics[operation].length,
        averageResponseTime: Math.round(this.getAverageMetric(operation)),
        averageGasUsage: Math.round(this.getAverageGas(operation)),
        minResponseTime: Math.min(...this.metrics[operation]),
        maxResponseTime: Math.max(...this.metrics[operation]),
        minGasUsage: Math.min(...this.gasUsage[operation]),
        maxGasUsage: Math.max(...this.gasUsage[operation])
      }
    })
    
    console.log('ğŸ“ˆ æ€§èƒ½æŠ¥å‘Š:', report)
    return report
  }

  // æ£€æŸ¥æ€§èƒ½è­¦å‘Š
  checkPerformanceWarnings() {
    const warnings: string[] = []
    
    Object.keys(this.metrics).forEach(operation => {
      const avgTime = this.getAverageMetric(operation)
      const avgGas = this.getAverageGas(operation)
      
      if (avgTime > 10000) { // è¶…è¿‡10ç§’
        warnings.push(`${operation} å“åº”æ—¶é—´è¿‡é•¿: ${avgTime}ms`)
      }
      
      if (avgGas > 500000) { // è¶…è¿‡50ä¸‡Gas
        warnings.push(`${operation} Gasæ¶ˆè€—è¿‡é«˜: ${avgGas.toLocaleString()}`)
      }
    })
    
    if (warnings.length > 0) {
      console.warn('âš ï¸ æ€§èƒ½è­¦å‘Š:', warnings)
    }
    
    return warnings
  }
}

// å…¨å±€æ€§èƒ½ç›‘æ§å®ä¾‹
export const performanceMonitor = new PerformanceMonitor()

// è£…é¥°å™¨ï¼šè‡ªåŠ¨ç›‘æ§åˆçº¦æ–¹æ³•æ€§èƒ½
export function monitorPerformance(operationName: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value
    
    descriptor.value = async function (...args: any[]) {
      const startTime = Date.now()
      
      try {
        const result = await method.apply(this, args)
        const duration = Date.now() - startTime
        
        // å¦‚æœç»“æœåŒ…å«Gasä¿¡æ¯ï¼Œè®°å½•å®ƒ
        if (result && result.gasUsed) {
          performanceMonitor.recordTransaction(
            operationName,
            Number(result.gasUsed),
            duration
          )
        } else {
          performanceMonitor.recordTransaction(operationName, 0, duration)
        }
        
        return result
      } catch (error) {
        const duration = Date.now() - startTime
        console.error(`âŒ ${operationName} æ‰§è¡Œå¤±è´¥ (${duration}ms):`, error)
        throw error
      }
    }
    
    return descriptor
  }
}
```

## 5. æ€»ç»“å’Œè·¯çº¿å›¾

### 5.1 å®æ–½ä¼˜å…ˆçº§

| ä¼˜å…ˆçº§ | æ”¹è¿›é¡¹ç›® | é¢„è®¡æ—¶é—´ | æŠ€æœ¯éš¾åº¦ | ä¸šåŠ¡ä»·å€¼ |
|--------|----------|----------|----------|----------|
| ğŸ”´ é«˜ | å¯ç”¨æ™ºèƒ½åˆçº¦è°ƒç”¨ | 1å‘¨ | ä½ | é«˜ |
| ğŸ”´ é«˜ | é…ç½®åˆçº¦åœ°å€ | 2å¤© | ä½ | é«˜ |
| ğŸŸ¡ ä¸­ | å®ç°äº‹ä»¶ç›‘å¬ | 1-2å‘¨ | ä¸­ | ä¸­ |
| ğŸŸ¡ ä¸­ | æ•°æ®åŒæ­¥æœºåˆ¶ | 2-3å‘¨ | ä¸­ | ä¸­ |
| ğŸŸ¢ ä½ | å®‰å…¨æ€§å¢å¼º | 1-2æœˆ | é«˜ | ä¸­ |
| ğŸŸ¢ ä½ | å¤šé“¾æ”¯æŒ | 2-3æœˆ | é«˜ | ä½ |
| ğŸŸ¢ ä½ | DeFiåŠŸèƒ½ | 3-6æœˆ | é«˜ | ä½ |

### 5.2 æˆåŠŸæŒ‡æ ‡

#### æŠ€æœ¯æŒ‡æ ‡
- âœ… æ‰€æœ‰æ™ºèƒ½åˆçº¦æ–¹æ³•æ­£å¸¸è°ƒç”¨
- âœ… äº‹ä»¶ç›‘å¬100%å·¥ä½œ
- âœ… æ•°æ®åŒæ­¥å»¶è¿Ÿ < 30ç§’
- âœ… äº¤æ˜“ç¡®è®¤æ—¶é—´ < 2åˆ†é’Ÿ
- âœ… Gasè´¹ç”¨ä¼˜åŒ– > 20%

#### ç”¨æˆ·ä½“éªŒæŒ‡æ ‡
- âœ… é¡µé¢åŠ è½½æ—¶é—´ < 3ç§’
- âœ… äº¤æ˜“æˆåŠŸç‡ > 95%
- âœ… é”™è¯¯ä¿¡æ¯æ¸…æ™°æ˜“æ‡‚
- âœ… ç§»åŠ¨ç«¯å…¼å®¹æ€§è‰¯å¥½

#### ä¸šåŠ¡æŒ‡æ ‡
- âœ… çœŸå®çš„é“¾ä¸Šæ•°æ®å­˜å‚¨
- âœ… å»ä¸­å¿ƒåŒ–äº¤æ˜“åŠŸèƒ½
- âœ… é€æ˜çš„æ’æ”¾è®°å½•
- âœ… å¯å®¡è®¡çš„äº¤æ˜“å†å²

### 5.3 é£é™©è¯„ä¼°å’Œç¼“è§£ç­–ç•¥

#### æŠ€æœ¯é£é™©
1. **æ™ºèƒ½åˆçº¦æ¼æ´**
   - ç¼“è§£ï¼šä»£ç å®¡è®¡ã€æµ‹è¯•ç½‘å……åˆ†æµ‹è¯•
   - åº”æ€¥ï¼šæš‚åœæœºåˆ¶ã€å‡çº§æœºåˆ¶

2. **Gasè´¹ç”¨æ³¢åŠ¨**
   - ç¼“è§£ï¼šGasè´¹ç”¨ä¼°ç®—ã€ç”¨æˆ·æé†’
   - åº”æ€¥ï¼šLayer 2è§£å†³æ–¹æ¡ˆ

3. **ç½‘ç»œæ‹¥å µ**
   - ç¼“è§£ï¼šå¤šç½‘ç»œæ”¯æŒã€ä¼˜å…ˆçº§é˜Ÿåˆ—
   - åº”æ€¥ï¼šç¦»çº¿æ¨¡å¼ã€æ‰¹é‡å¤„ç†

#### ç”¨æˆ·ä½“éªŒé£é™©
1. **é’±åŒ…è¿æ¥é—®é¢˜**
   - ç¼“è§£ï¼šè¯¦ç»†çš„è¿æ¥æŒ‡å—ã€å¤šé’±åŒ…æ”¯æŒ
   - åº”æ€¥ï¼šå®¢æœæ”¯æŒã€FAQæ–‡æ¡£

2. **äº¤æ˜“å¤±è´¥**
   - ç¼“è§£ï¼šé¢„æ£€æŸ¥ã€æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯
   - åº”æ€¥ï¼šé‡è¯•æœºåˆ¶ã€äººå·¥å¤„ç†

### 5.4 ä¸‹ä¸€æ­¥è¡ŒåŠ¨è®¡åˆ’

#### ç¬¬1å‘¨ï¼šç«‹å³è¡ŒåŠ¨
1. âœ… ä¿®æ”¹Emissions.tsxå¯ç”¨æ™ºèƒ½åˆçº¦è°ƒç”¨
2. âœ… ä¿®æ”¹Market.tsxå¯ç”¨æ™ºèƒ½åˆçº¦è°ƒç”¨
3. âœ… é…ç½®ç¯å¢ƒå˜é‡å’Œåˆçº¦åœ°å€
4. âœ… åŸºç¡€é”™è¯¯å¤„ç†å®ç°
5. âœ… åœ¨æµ‹è¯•ç½‘éƒ¨ç½²åˆçº¦

#### ç¬¬2-4å‘¨ï¼šæ ¸å¿ƒåŠŸèƒ½
1. âœ… å®ç°äº‹ä»¶ç›‘å¬æœºåˆ¶
2. âœ… æ•°æ®åŒæ­¥æœåŠ¡å¼€å‘
3. âœ… æ€§èƒ½ç›‘æ§é›†æˆ
4. âœ… ç”¨æˆ·ä½“éªŒä¼˜åŒ–
5. âœ… å…¨é¢æµ‹è¯•å’Œè°ƒè¯•

#### ç¬¬2-3ä¸ªæœˆï¼šå¢å¼ºåŠŸèƒ½
1. âœ… æ™ºèƒ½åˆçº¦å®‰å…¨å®¡è®¡
2. âœ… å¤šé“¾æ”¯æŒå¼€å‘
3. âœ… é«˜çº§DeFiåŠŸèƒ½
4. âœ… ç§»åŠ¨ç«¯ä¼˜åŒ–
5. âœ… ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

---

**æ€»ç»“ï¼š** è¿™ä¸ªæ”¹è¿›å®æ–½æ–¹æ¡ˆæä¾›äº†ä»ç«‹å³å¯è¡Œçš„ä¿®å¤åˆ°é•¿æœŸæ„¿æ™¯çš„å®Œæ•´è·¯å¾„ã€‚é€šè¿‡åˆ†é˜¶æ®µå®æ–½ï¼Œå¯ä»¥å¿«é€Ÿå®ç°çœŸæ­£çš„åŒºå—é“¾åŠŸèƒ½ï¼ŒåŒæ—¶ä¸ºæœªæ¥çš„æ‰©å±•å¥ å®šåšå®åŸºç¡€ã€‚å…³é”®æ˜¯å…ˆè§£å†³æ ¸å¿ƒçš„æ™ºèƒ½åˆçº¦è°ƒç”¨é—®é¢˜ï¼Œç„¶åé€æ­¥å¢å¼ºåŠŸèƒ½å’Œç”¨æˆ·ä½“éªŒã€‚